\chapter{Implementacja projektu}
\label{chap:implementacja}

W niniejszym rozdziale przedstawiono proces tworzenia aplikacji. Pokazano fragmenty kodu realizuj¹ce kluczowe funkcjonalnoœci, jak np.:~uwierzytelnianie, rejestrowanie œladów czy prezentacja statystyk. Zawarto równie¿ rysunki, na których ukazane s¹ widoki aplikacji.

Przebieg procesu implementacji projektu mo¿na podzieliæ na etapy, których kolejnoœæ przedstawiono poni¿ej. Jednak w praktyce prace nad pewnymi etapami prowadzono równolegle, jak np.:~nagrywanie œladów oraz kalkulator statystyk. Wynika to naturalnie z faktu, ¿e pewne etapy s¹ ze sob¹ œciœlej powi¹zane, a co za tym idzie --- zmiany wprowadzone w jednej czêœci systemu, poci¹gaj¹ za sob¹ zmiany w drugiej czêœci systemu.
\begin{enumerate}
  \item Inicjalizacja aplikacji klienta.
  \item Inicjalizacja \texttt{Firebase}.
  \item Integracja z \texttt{Firebase}.
  \item Integracja z \texttt{Firebase Hosting}.
  \item Konfiguracja PWA.
  \item Projekt struktury bazy danych.
  \item Implementacja uk³adów stron.
  \item Implementacja uwierzytelniania.
  \item Implementacja routingu.
  \item Implementacja rejestratora GPS.
  \item Implementacja kalkulatora statystyk œladu.
  \item Implementacja importu œladów GPS.
  \item Implementacja eksportu œladów GPS.
  \item Implementacja aktywnoœci.
  \item Integracja z \texttt{Realtime Database}.
  \item Implementacja profilu u¿ytkownika.
  \item Implementacja kalkulatora statystyk profilu.
\end{enumerate}

Pracê nad projektem prowadzono z u¿yciem edytora \texttt{Visual Studio Code}. Zmiany w kodzie regularnie zapisywano do zdalnego repozytorium \texttt{GitHub}. Repozytorium jest publiczne, a~dostêp do niego mo¿na uzyskaæ pod adresem:~\url{https://github.com/michaltkacz/biker}.

\section {Inicjalizacja aplikacji klienta}
Projekt aplikacji klienta utworzono przez uruchomienie komendy w œrodowisku \texttt{Node.js}, przedstawionej na listingu~\ref{lst:npx}. Dziêki wykorzystaniu flagi \texttt{--template cra-template-pwa-typescript} projekt zainicjalizowano w konfiguracji z jêzykiem \texttt{TypeScript} oraz z zaimplementowanym \emph{service-workerem} odpowiedzialnym za dzia³anie aplikacji w trybie PWA. Nastêpnie projekt oczyszczono ze zbêdnych plików oraz zainstalowano kluczowe, dodatkowe biblioteki (ponownie listing~\ref{lst:npx}) konieczne do rozpoczêcia pracy nad kodem (pozosta³e biblioteki w miarê zapotrzebowania doinstalowywano w póŸniejszych etapach rozwoju aplikacji).

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[label=lst:npx, caption=Inicjalizacja projektu React oraz instalacja kluczowych bibliotek, basicstyle=\footnotesize\ttfamily]
npx create-react-app react-pwa-ts --template cra-template-pwa-typescript
cd react-pwa-ts
npm i react-router
npm i antd
npm i firebase
npm i firebaseui
npm i firebaseui
npm i craco
npm i craco-less
npm i leaflet
npm i react-leaflet
npm i react-icons
\end{lstlisting}
  }

\begin{figure}[htb]
  \centering
  \begin{tabular}{@{}ll@{}}
    a)                                                                                     & b) \\
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.375\textwidth]{rys03/filetree1.png}}}} &
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.375\textwidth]{rys03/filetree2.png}}}}
  \end{tabular}
  \caption{Drzewo plików projektu: a) po inicjalizacji, b) po usuniêciu zbêdnych plików}
  \label{fig:filetree}
\end{figure}


\section {Inicjalizacja \texttt{Firebase}}
W celu inicjalizacji projektu Firebase nale¿y odwiedziæ stronê: \url{https://firebase.google.com/}, a nastêpnie postêpowaæ zgodnie z instrukcjami wyœwietlanymi na stronie, lub zgodnie z oficjaln¹ dokumentacj¹~\cite{fireinit}. Po pomyœlnej inicjalizacji, deweloper zyskuje dostêp do konsoli (\texttt{Firebase Console}) (rys.~\ref{fig:fireconsole}), która pozwala na zarz¹dzanie projektem. W menu po lewej stronie, w zak³adce \emph{Build} dostêpne s¹ poszczególne modu³y. Trzy z nich: \texttt{Authentication}, \texttt{Realtime Database} i \texttt{Hosting}, omówiono w dalszej czêœci~rozdzia³u.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{rys03/fireconsole.png}
  \caption{Widok g³ównej strony \texttt{Firebase Console}}
  \label{fig:fireconsole}
\end{figure}

\section {Integracja z \texttt{Firebase}}
W folderze z plikami Ÿród³owymi projektu aplikacji klienta utworzono nowy plik o nazwie \texttt{firebase.tsx}. Nastêpnie zawarto w nim kod konfiguracji \texttt{Firebase}, który skopiowano z~konsoli (rys.~\ref{fig:fireconfig}). Na podstawie tej konfiguracji, w pliku \texttt{src/firebase/firebase.tsx} zainicjalizowano modu³ aplikacji \texttt{Firebase}. W póŸniejszych etapach zainicjalizowano równie¿ obiekty autoryzacji \texttt{auth} oraz bazy danych \texttt{database}. Pozwalaj¹ one z poziomu aplikacji klienta odwo³ywaæ siê do odpowiednich funkcjonalnoœci po stronie \texttt{Firebase'a}. Finaln¹ wersjê pliku przedstawiono na listingu~\ref{lst:fireinit}

{\belowcaptionskip=-9pt
  \begin{lstlisting}[language=JavaScript,style=JavaScriptStyle, label=lst:fireinit, caption=Integracja aplikacji klienta z projektem \texttt{Firebase}, basicstyle=\footnotesize\ttfamily]
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getDatabase } from 'firebase/database';

const firebaseConfig = {
  apiKey: 'AIzaSyASclbvuJjuN5f1tSCixm9swsIvTeH9ZQk',
  authDomain: 'biker-784a8.firebaseapp.com',
  projectId: 'biker-784a8',
  databaseURL:
    'https://biker-784a8-default-rtdb.europe-west1.firebasedatabase.app/',
  storageBucket: 'biker-784a8.appspot.com',
  messagingSenderId: '993843027751',
  appId: '1:993843027751:web:dc5f8671671126b4501302',
};

const firebaseApp = initializeApp(firebaseConfig);

export const auth = getAuth(firebaseApp);
export const database = getDatabase(firebaseApp);

export default firebaseApp;
\end{lstlisting}
}

\begin{figure}[hb]
  \centering
  \includegraphics[width=\linewidth]{rys03/fireconfig.png}
  \caption{Kod obiektu konfiguracyjnego dostêpny w \texttt{Firebase Console}}
  \label{fig:fireconfig}
\end{figure}

Zawartoœæ obiektu konfiguracyjnego jest unikalna dla danego projektu, jednak nie jest ona sekretna. W celu zabezpieczenia danych przechowywanych w bazie, nale¿y wykorzystaæ \texttt{Firebase Security Rules}. Regu³y bezpieczeñstwa zastosowane w projekcie omówiono w~dalszej czêœci rozdzia³u. Wiêcej informacji na temat obiektu konfiguracyjnego mo¿na znaleŸæ w dokumentacji~\cite{fireconfig}


\section {Integracja z \texttt{Firebase Hosting}}
Integracjê z us³ug¹ hostingu przeprowadzono wed³ug dokumentacji~\cite{firehosting}. W pierwszym kroku, w katalogu g³ównym projektu, z poziomu wiersza poleceñ wykonano komendê \texttt{firebase init hosting}. Uruchamia ona intuicyjny konfigurator, który w kilku krokach pozwala skonfigurowaæ projekt do us³ugi hostowania. Po zakoñczeniu konfiguracji w katalogu g³ównym projektu powsta³y dwa pliki:~\texttt{.firebaserc} oraz \texttt{firebase.json}, których zawartoœæ pokazano odpowiednio na listingu~\ref{lst:firerc} i listingu~\ref{lst:firejson}. Pierwszy z nich to konfiguracja aliasów projektu. Jest to u¿yteczne w przypadku, gdy w jednym projekcie u¿ywanych jest wiele projektów \texttt{Firebase}. Drugi plik, to konfiguracja us³ugi hostingu. Dziêki niemu mo¿na ustawiæ takie opcje hostingu, jak np.:~przekierowania URL, nadpisania URL, czy nawet wyœwietlanie ukoœnika na koñcu adresu URL~(\emph{trailing-slash}).

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[style=json-style, label=lst:firerc, caption=Zawartoœæ pliku \texttt{.firebaserc}, basicstyle=\footnotesize\ttfamily]
{
  "projects": {
    "default": "biker-784a8"
  }
}
\end{lstlisting}
  }

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[style=json-style, label=lst:firejson, caption=Zawartoœæ pliku \texttt{firebase.json}, basicstyle=\footnotesize\ttfamily]
{
  "hosting": {
    "site": "biker-784a8",
    "public": "build",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
\end{lstlisting}
  }

W kolejnym kroku zbudowano aplikacjê klienta z u¿yciem polecenia \texttt{npm run build}, a nastêpnie wywo³ano polecenie \texttt{firebase hosting deploy}. W wyniku tej procedury, zbudowan¹ aplikacjê opublikowano pod adresami: \url{biker-784a8.web.app} oraz \url{biker-784a8.firebaseapp.com}. Po wprowadzeniu zmian w projekcie, w celu aktualizacji hostowanej aplikacji, proces budowania i publikacji nale¿y powtórzyæ.

\section {Konfiguracja PWA}
W celu aktywacji opcji instalacji aplikacji jako PWA, oprócz rejestracji \emph{service-workera}, konieczna jest konfiguracja ustawieñ przy pomocy pliku \texttt{public/manifest.json}. Dokumentacja dostêpna jest pod adresem \cite{pwamanifest}. Finaln¹ wersjê manifestu przedstawiono na listingu~\ref{lst:pwamanifest}, a jego wyjaœnienie zawarto w tabeli~\ref{tab:pwamanifest}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[style=json-style, label=lst:pwamanifest, caption=Zawartoœæ pliku \texttt{manifest.json}, basicstyle=\footnotesize\ttfamily]
{
  "background_color": "white",
  "categories": ["sport"],
  "description": "Cycling Navigation. Monitor all your cycling statistics in one place.",
  "dir": "ltr",
  "display": "standalone",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64",
      "type": "image/x-icon"
    },
    {
      "src": "logo.svg",
      "sizes": "any",
      "type": "image/svg+xml"
    },
    {
      "src": "logo_maskable.svg",
      "sizes": "any",
      "type": "image/svg+xml",
      "purpose": "maskable"
    }
  ],
  "lang": "en-US",
  "name": "Biker",
  "orientation": "portrait",
  "short_name": "Biker",
  "start_url": "/",
  "theme_color": "white"
}
\end{lstlisting}
}

\begin{table}[htb] \small
  \centering
  \caption{Wyjaœnienie zawartoœci pliku \texttt{manifest.json}}
  \label{tab:pwamanifest}
  \begin{tabularx}{\linewidth}{|l|X|} \hline
    Atrybut                                           & Opis                                              \\      \hline\hline
    \texttt{background\_color}, \texttt{theme\_color} & Kolor t³a oraz kolor motywu aplikacji             \\      \hline
    \texttt{categories}                               & Kategoria, do której nale¿y aplikacja             \\      \hline
    \texttt{description}                              & Opis aplikacji                                    \\      \hline
    \texttt{dir}, \texttt{lang}                       & Kierunek tekstu oraz jêzyk wyœwietlania aplikacji \\      \hline
    \texttt{display}, \texttt{orientation}            & Tryb wyœwietlania aplikacji oraz jej orientacja   \\      \hline
    \texttt{icons}                                    & Zestaw ikon aplikacji                             \\      \hline
    \texttt{name}, \texttt{short\_name}               & Nazwa oraz skrócona nazwa aplikacji               \\      \hline
    \texttt{start\_url}                               & Adres URL punktu wejœcia do aplikacji             \\      \hline
  \end{tabularx}
\end{table}

Ikony aplikacji (rys.~\ref{fig:pwaicons}) --- \texttt{logo.svg}, \texttt{logo\_maskable.svg}, \texttt{favicon.ico} --- zosta³y wykonane w programie do tworzenia grafiki wektorowej \texttt{Inkscape}. Ikony \texttt{favicon.ico} oraz \texttt{logo\_maskable.svg} ró¿ni¹ siê jedynie rozmiarem marginesu symbolu.

\begin{figure}[htb]
  \centering
  \begin{tabular}{@{}ll@{}}
    a)                                                                                & b) \\
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.475\textwidth]{rys03/logo.png}}}} &
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.475\textwidth]{rys03/logo_maskable.png}}}}
  \end{tabular}
  \caption{Ikony aplikacji: a) logo, b) logo\_maskable (favicon z mniejszym marginesem)}
  \label{fig:pwaicons}
\end{figure}


\section {Projekt struktury bazy danych}
Korzystaj¹c z mo¿liwoœci jêzyka TypeScript, w projekcie utworzono typy danych definiuj¹ce po stronie klienta strukturê bazy danych. Typy te s¹ reprezentacj¹ drzewa obiektów przedstawionego na rysunku~\ref{lst:database}. Wykorzystanie sztywno zdefiniowanych typów gwarantuje spójnoœæ danych na przestrzeni ca³ej aplikacji oraz u³atwia integracjê z baz¹ danych po stronie \texttt{Firebase'a}. Dodatkow¹ zalet¹ jest ³atwiejsza kontrola b³êdów oraz unikniêcie nieprzewidzianego zachowania aplikacji. Zawartoœæ lisingów~\ref{lst:dbtypes1}, \ref{lst:dbtypes2}, \ref{lst:dbtypes3}, \ref{lst:dbenums} odpowiada plikowi \texttt{src/database/schema.tsx}.

Na listingu~\ref{lst:dbtypes1} przedstawiono strukturê typów w ogólnym ujêciu. \texttt{DatabaseSchema} odpowiada instancji bazy danych po stronie \texttt{Realtime Database}, a~zawartoœci¹ obiektu s¹ obiekty u¿ytkowników kluczowane unikalnym identyfikatorem u¿ytkownika (identyfikator jest generowany automatycznie przez \texttt{Firebase} przy rejestracji nowego konta). Ka¿dy obiekt u¿ytkownika zawiera swój identyfikator, obiekt profilu, obiekt aktywnoœci i obiekt œladów. W obiekcie profilu z kolei przechowywane s¹ dane personalne u¿ytkownika: p³eæ, data urodzenia, waga, wzrost, kraj i miasto zamieszkania oraz opis.

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:dbtypes1, caption=Typy obiektowe struktury bazy danych (1/3) --- \emph{root} bazy danych oraz u¿ytkownik, basicstyle=\footnotesize\ttfamily]
type DatabaseSchema = {
  users?: { [userId: string]: User };
};
export type User = {
  userId: string;
  profile?: UserProfile;
  activities?: { [activityId: string]: Activity };
  tracks?: { [trackId: string]: Track };
  };
export type UserProfile = {
  gender?: GenderTypes;
  birthday?: string;
  weight?: number;
  height?: number;
  country?: string;
  city?: string;
  description?: string;
};
\end{lstlisting}
  }

Na listingu~\ref{lst:dbtypes2} pokazano typ aktywnoœci, która zawiera w sobie szczegó³owe dane o zapisanej podró¿y rowerowej, w tym podstawowe statystki œladu. Wœród statystyk nie ma zapisanych ¿adnych wartoœci uœrednionych (np.:~œrednia prêdkoœæ, œrednia elewacja), poniewa¿ mo¿na je ³atwo wyliczyæ z pozosta³ych, dostêpnych statystyk.

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:dbtypes2, caption=Typy obiektowe struktury bazy danych (2/3) --- aktywnoœci, basicstyle=\footnotesize\ttfamily]
export type Activity = {
  activityId: string;
  creatorId: string;
  name: string;
  createdAt: number;
  lastModifiedAt: number;
  startTime: number;
  endTime: number;
  sport: ActivitySportTypes;
  category: ActivityCategoryTypes;
  shape: ActivityShape;
  statistics: ActivityStatistics;
  rating?: RatingTypes;
  tags?: Array<string>;
};
export type ActivityShape = {
  isLoop: boolean;
  from: string;
  to: string;
};
export type ActivityStatistics = {
  totalDistance?: number;
  totalDuration?: number;
  inMotionDuration?: number;
  maxSpeed?: number;
  elevationUp?: number;
  elevationDown?: number;
  minElevation?: number;
  maxElevation?: number;
};
\end{lstlisting}
  }

Typy \texttt{Track}, \texttt{TrackSegment} i \texttt{TrackPoint} zdefiniowano na wzór standardu GPX --- odpowiednio \texttt{trkType}, \texttt{trksegType} i \texttt{ptType}. Zatem obiekt œladu sk³ada siê z listy segmentów oraz dodatkowo z identyfikatora aktywnoœci, do której nale¿y. Z kolei jeden segment, to lista punktów, które opisuj¹ szerokoœæ i d³ugoœæ geograficzn¹, czas zarejestrowania po³o¿enia oraz ewentualn¹ bezwzglêdn¹ wysokoœæ nad poziomem morza. Definicje typów zawarto w~listingu~\ref{lst:dbtypes3}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:dbtypes3, caption=Typy obiektowe struktury bazy danych (3/3) ---  œlady, basicstyle=\footnotesize\ttfamily]
export type Track = {
  activityId: string;
  segments: Array<TrackSegment>;
};
export type TrackSegment = Array<TrackPoint>;
export type TrackPoint = {
  lat: number;
  lon: number;
  time: number;
  ele?: number | null;
};
\end{lstlisting}
}

Oprócz typów obiektowych zdefiniowano równie¿ cztery typy wyliczeniowe, które przedstawiono na listingu~\ref{lst:dbenums}. Okreœlaj¹ one dostêpne dla u¿ytkownika opcje wyboru dla danych: p³eæ u¿ytkownika, rodzaj sportu aktywnoœci, kategoria aktywnoœci oraz ocena aktywnoœci.

\begingroup
\listingcaption{Typy wyliczeniowe struktury bazy danych}
\setlength\multicolsep{0pt plus 2pt}%
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, multicols=2, label=lst:dbenums]
export enum GenderTypes {
  Male = 'male',
  Female = 'female',
  Other = 'other',
}
export enum ActivitySportTypes {
  Touring = 'touring',
  MTB = 'mtb',
  Enduro = 'enduro',
  Downhill = 'downhill',
  Gravel = 'gravel',
  Road = 'road',
  BMX = 'bmx',
  Tandem = 'tandem',
  Cyclocross = 'cyclocross',
  Track = 'track',
  Speedway = 'speedway',
  Other = 'other',
}
export enum ActivityCategoryTypes {
  Commute = 'commute',
  Casual = 'casual',
  Workout = 'training',
  Race = 'race',
  Bikepacking = 'bikepacking',
  Other = 'other',
}
export enum RatingTypes {
  Terrible = 'terrible',
  Poor = 'poor',
  Fair = 'fair',
  Good = 'good',
  Excellent = 'excellent',
}
\end{lstlisting}
\vspace{6pt plus 2pt}
\endgroup

\section{Implementacja uk³adów stron}
W aplikacji zaimplementowano dwa ró¿ne uk³ady strony --- jeden wy³¹cznie dla strony autoryzacji, a drugi -- globalny, wspólny dla wszystkich pozosta³ych stron. Uk³ady s¹ w pe³ni responsywne, co oznacza, ¿e dynamicznie dostosowuj¹ siê one do rozmiaru ekranu urz¹dzenia. Responsywnoœæ uzyskano dziêki zastosowaniu zasad CSS typu \texttt{@media min-width}.

Szablon uk³adu strony autoryzacji przedstawiaj¹: w wersji desktopowej (dla ekranu o szerokoœci powy¿ej 768px)--- rysunek~\ref{fig:authpagetemplatedesktop}, a w wersji mobilnej --- rysunek~\ref{fig:authpagemobile}a (dla ekranu o szerokoœci nie przekraczaj¹cej 768px). Gotowe widoki aplikacji dla powy¿szych szablonów pokazano odpowiednio na rysunku~\ref{fig:authpagedesktop} oraz rysunku~\ref{fig:authpagemobile}b.

Szablon globalny (rys.~\ref{fig:globaltemplatepage}), wykorzystano do zbudowania stron: profilu u¿ytkownika, rejestratora GPS oraz aktywnoœci (rys.~\ref{fig:globalpage}). Jest on równie¿ w pe³ni responsywny. Dla ekranów o rozmiarze powy¿ej 1200px \emph{sider} przyjmuje on sta³¹ szerokoœæ 200px i nie mo¿e zostaæ ukryty, natomiast \emph{content} wype³nia ca³e pozosta³e miejsce. W przypadku ekranów nie wiêkszych ni¿ 1200px, \emph{sider} staje siê dynamiczny --- mo¿e zostaæ ukryty przy u¿yciu przycisku \emph{sider button}. Z kolei \emph{content} przyjmuje sta³¹ szerokoœæ równ¹ ca³kowitej szerokoœci okna widoku. Z tego wzglêdu otwarcie \emph{sidera} powoduje wypchniêcie \emph{contentu} o 200px w prawo, poza obszar ekranu. Jest to zabieg umyœlny, który ma na celu zminimalizowanie efektu \emph{content jumpingu}, czyli niechcianej zmiany po³o¿enia elementów strony. Efekt ten by³ szczególnie zauwa¿alny na urz¹dzeniach z w¹skim ekranem, jak np.:~smartfonach.

% Kod komponentu strony autoryzacji zawarto w listingu~\ref{lst:authpage}.

% {\belowcaptionskip=-9pt
% \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:authpage, caption=Komponent strony uwierzytelniania, basicstyle=\footnotesize\ttfamily]
% const AuthPage: React.FC = () => {
%   return (
%     <div className='auth-page'>
%       <div className='auth-page-content'>
%         <Hero />
%         <Auth />
%       </div>
%     </div>
%   );
% };
% \end{lstlisting}
% }

% \newpage
\begin{figure}[htp]
  \centering
  \includegraphics[width=\linewidth]{rys03/authpagetemplatedesktop}
  \caption{Szablon uk³adu strony autoryzacji w wersji desktopowej}
  \label{fig:authpagetemplatedesktop}
\end{figure}

\begin{figure}[htp]
  \centering
  \includegraphics[width=\linewidth]{rys03/authpagedesktop}
  \caption{Widok strony autoryzacji w wersji desktopowej}
  \label{fig:authpagedesktop}
\end{figure}

% \newpage
\begin{figure}[htp]
  \centering
  \begin{tabular}{@{}ll@{}}
    a)                                                                                              & b) \\
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.475\textwidth]{rys03/authpagetemplatemobile}}}} &
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.475\textwidth]{rys03/authpagemobile}}}}
  \end{tabular}
  \caption{Uk³ad strony autoryzacji a) szablon, b) widok aplikacji}
  \label{fig:authpagemobile}
\end{figure}

% \begin{figure}[ht]
%   \centering
%   \includegraphics[width=0.4\linewidth]{rys03/authpagetemplatemobile}
%   \caption{Szablon uk³adu strony autoryzacji w wersji mobilnej}
%   \label{fig:authpagetemplatemobile}
% \end{figure}

% \begin{figure}[ht]
%   \centering
%   \includegraphics[width=0.4\linewidth]{rys03/authpagemobile}
%   \caption{Widok strony autoryzacji w wersji mobilnej}
%   \label{fig:authpagemobile}
% \end{figure}

% \newpage
\begin{figure}[htp]
  \centering
  \includegraphics[width=\linewidth]{rys03/globaltemplatepage}
  \caption{Szablon globalnego uk³adu strony w wersji mobilnej i desktopowej}
  \label{fig:globaltemplatepage}
\end{figure}

\begin{figure}[htp]
  \centering
  \includegraphics[width=\linewidth]{rys03/globalpage}
  \caption{Widok strony aktywnoœci w wersji desktopowej}
  \label{fig:globalpage}
\end{figure}


\section{Implementacja uwierzytelniania}
Do implementacji uwierzytelniania wykorzystano modu³ \texttt{Firebase Authentication} oraz bibliotekê \texttt{FirebaseUI}. W pierwszym kroku, w pliku \texttt{src/firebase/firebase.tsx} zainicjalizowano modu³ autentykacji, jak pokazano na listingu~\ref{lst:fireinit}. Nastêpnie utworzono komponent \texttt{Auth} (jak pokazano na listingu~\ref{lst:authcomponent}), który przy pierwszym renderowaniu uruchamia us³ugê uwierzytelniania z biblioteki \texttt{FirebaseUI}. Funkcjê \texttt{startFirebaseUI} zaimplementowano w pliku \texttt{src/firebase/firebaseUI.tsx}, jej kod oraz konfiguracjê biblioteki przedstawiono na listingu~\ref{lst:firebaseui}. W wyniku dzia³ania funkcji, do kontenera o identyfikatorze \texttt{\#firebaseui-auth-container} wstrzykniêty zostaje komponent autoryzacji, który zgodnie podan¹ konfiguracj¹ umo¿liwia autoryzacjê dwiema metodami: przez podanie adresu email oraz has³a lub przez konto \texttt{Google}. Komponent widoczny jest na rysunku~\ref{fig:globalpage}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:authcomponent, caption=Komponent uwierzytelniania, basicstyle=\footnotesize\ttfamily]
const Auth: React.FC = () => {
  useEffect(() => {
    startFirebaseUI();
  }, []);
  return (
    <div className='auth'>
      <Typography.Title level={2} className='auth-title'>
        Sign In
      </Typography.Title>
      <div id={elementID} className='auth-widget'></div>
    </div>
  );
};
\end{lstlisting}
}

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:firebaseui, caption=Autoryzacja z u¿yciem biblioteki \texttt{FirebaseUI}, basicstyle=\footnotesize\ttfamily]
const firebaseUI = new firebaseui.auth.AuthUI(auth);
export const firebaseUiDefaultConfig: firebaseui.auth.Config = {
  signInFlow: 'popup',
  signInOptions: [
    EmailAuthProvider.PROVIDER_ID,
    GoogleAuthProvider.PROVIDER_ID,
  ],
  tosUrl: 'https://en.wikipedia.org/wiki/Terms_of_service',
  privacyPolicyUrl: 'https://en.wikipedia.org/wiki/Privacy_policy',
};
export const elementID: string = 'firebaseui-auth-container';
export const startFirebaseUI = () => {
  firebaseUI.start('#' + elementID, firebaseUiDefaultConfig);
};
\end{lstlisting}

Dane zalogowanego u¿ytkownika dostêpne s¹ w przestrzeni aplikacji dziêki wykorzystaniu kontekstu~\cite{reactcontext} o nazwie \texttt{AuthContext}, którego definicja znajduje siê w pliku \texttt{src/firebase/contexts/AuthContext.tsx}. Najwa¿niejsze jego funkcje przedstawiono na listingu~\ref{lst:authcontext}. Kluczowym dzia³aniem jest subskrypcja \texttt{onAuthStateChanged}, która nas³uchuje odpowiedzi ze strony \texttt{Firebase}. W przypadku pojawienia siê poprawnej odpowiedzi, otrzymywany jest obiekt u¿ytkownika. Nastêpnie obiekt ten jest zapisany jako \texttt{currentUser}. Wszystkie komponenty bêd¹ce potomkami (widoczne na listingu~\ref{lst:routing}) kontekstu posiadaj¹ dostêp do obiektu u¿ytkownika poprzez hook~\cite{reacthooks} \texttt{useAuth}, zdefiniowany w pliku \texttt{src/firebase/hooks/useAuth.tsx}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:authcontext, caption=Komponent kontekstu uwierzytelniania, basicstyle=\footnotesize\ttfamily]
export const AuthContext = createContext<IAuthContext | undefined>(undefined);
export const AuthContextProvider: React.FC = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  ...
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(
      auth,
      (user) => {
        setCurrentUser(user);
        ...
      },
      (error) => {
        setCurrentUser(null);
        ...
      }
    );
    return unsubscribe;
  }, []);
  ...
  const logoutUser = (): void => {
    signOut(auth);
  };
  const currentUserId = currentUser ? currentUser.uid : null;
  const value: IAuthContext = {
    currentUser,
    currentUserId,
    updateUser,
    logoutUser,
  };
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};
\end{lstlisting}

\section{Implementacja routingu}
Dynamiczny routing po stronie klienta zaimplementowano z wykorzystaniem biblioteki \texttt{React Router}. strukturê routingu pokazano na listingu~\ref{lst:routing}. Trasa do strony autoryzacji jest publiczna, natomiast trasy do stron: profilu, rejestratora GPS i aktywnoœci s¹ prywatne. W przypadku próby dostêpu do niezdefiniowanej trasy, nastêpuje przekierowanie na stronê \texttt{NotFoundPage}, która informuje u¿ytkownika, ¿e strona pod zadan¹ tras¹ nie istnieje.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:routing, caption=Struktura aplikacji oraz routing aplikacji, basicstyle=\footnotesize\ttfamily]
  const App: React.FC = () => {
    return (
      <Router>
        <AuthContextProvider>
          <PageLayout>
            <Switch>
              <RoutePublic exact path={`/${Pages.Authorize}`}>
                <AuthPage />
              </RoutePublic>
              <RoutePrivate exact path={`/${Pages.Profile}`}>
                <ProfilePage />
              </RoutePrivate>
              <RoutePrivate exact path={`/${Pages.Tracker}`}>
                <TrackerPage />
              </RoutePrivate>
              <RoutePrivate exact path={`/${Pages.Activities}`}>
                <ActivitiesPage />
              </RoutePrivate>
              <Route path='/*' component={NotFoundPage} />
            </Switch>
          </PageLayout>
        </AuthContextProvider>
      </Router>
    );
  };
\end{lstlisting}

Do tras publicznych maj¹ dostêp wszyscy u¿ytkownicy nieuwierzytelnieni. Komponent \texttt{PublicPrivate} przedstawiono na listingu~\ref{lst:privateroute}. Je¿eli trasê próbuje odwiedziæ u¿ytkownik uwierzytelniony, to nastêpuje przekierowanie na stronê profilu u¿ytkownika. Zabieg ten ma na celu zablokowanie dostêpu do strony autoryzacji w przypadku, gdy w aplikacji jest ju¿ zalogowany u¿ytkownik.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:privateroute, caption=Publiczna trasa routingu, basicstyle=\footnotesize\ttfamily]
const RoutePublic: React.FC<RouteProps> = ({ children, ...rest }) => {
  const { currentUser } = useAuth();
  return (
    <Route
      {...rest}
      render={() => (!currentUser ? children : <Redirect to={Pages.Profile} />)}
    />
  );
};
\end{lstlisting}

Trasa prywatna to taka, do której dostêp maj¹ jedynie u¿ytkownicy uwierzytelnieni. Komponent \texttt{RoutePrivate} przedstawiono na listingu~\ref{lst:privateroute}. Je¿eli w aplikacji jest uwierzytelniony u¿ytkownik, to zwracany jest docelowy komponent trasy. W przeciwnym razie nastêpuje przekierowanie na stronê uwierzytelniania.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:privateroute, caption=Prywatna trasa routingu, basicstyle=\footnotesize\ttfamily]
const RoutePrivate: React.FC<RouteProps> = ({ children, ...rest }) => {
  const { currentUser } = useAuth();
  return (
    <Route
      {...rest}
      render={() =>
        currentUser ? children : <Redirect to={Pages.Authorize} />
      }
    />
  );
};
\end{lstlisting}


\section{Implementacja rejestratora GPS}
Schemat strony rejestratora GPS przedstawiono na rysunku~\ref{fig:trackerpage}. Komponent \texttt{TrackerPage} zawiera trzy komponenty:
\begin{enumerate}
  \item \texttt{Map} --- komponent mapy, odpowiedzialny za wyœwietlanie mapy, obecnej pozycji na mapie (w postaci markera) oraz œladu GPS w postaci linii ³amanej.
  \item \texttt{MapControls} --- komponent z przyciskami steruj¹cymi zachowaniem mapy (œledzenie pozycji i centrowanie widoku do obecnej pozycji) oraz z przyciskiem w³¹czaj¹cym lub wy³¹czaj¹cym rejestrator GPS.
  \item \texttt{MapDashboard} --- komponent wyœwietlaj¹cy statystki aktualnie nagrywanego œladu. Statystki wyliczane s¹ w \emph{hooku} \texttt{useActivityStatistics}.
\end{enumerate}

Kluczowa logika strony zawarta jest w \emph{hooku} \texttt{useTracker}, którego najwa¿niejszym zadaniem jest rejestrowanie œladu GPS. Kod programu realizuj¹cy to zadanie przedstawiono na listingu~\ref{lst:trackerpage}. Po w³¹czeniu nagrywania stan \texttt{track} ustawiany jest na wartoœæ bêd¹c¹ tablic¹ zawieraj¹c¹ jeden pusty segment (pust¹ tablicê punktów), a stan \texttt{isTracking} ustawiany jest na wartoœæ \texttt{true}, czego skutkiem jest aktywacja \emph{hooka} \texttt{useInterval}. Interwa³ wywo³uje funkcjê \texttt{updateTrack} co 2000ms.

Funkcja \texttt{updateTrack} najpierw sprawdza warunek, czy najnowsza pozycja jest dostêpna (w przypadku b³êdu uzyskania lokalizacji przez przegl¹darkê, ostatnia pozycja przyjmuje wartoœæ \texttt{null}). Gdy pozycja jest niedostêpna i gdy ostatni segment \texttt{tracka} nie jest pusty, do \texttt{tracka}, na koniec tablicy dodawany jest nowy pusty segment. W przeciwnym wypadku --- gdy dostêpna jest nowa pozycja --- dopisywana jest ona na koñcu ostatniego segmentu \texttt{tracka}. Ponadto, aktywne nagrywanie blokuje wygaszacz ekranu urz¹dzenia (funkcje \texttt{enableNoSleep} \texttt{disableNoSleep} z \emph{hooka} \texttt{useNoSleep}).

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{rys03/trackerpage}
  \caption{Schemat strony rejestratora œladów GPS}
  \label{fig:trackerpage}
\end{figure}

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:trackerpage, caption=Kod strony rejestratora GPS, basicstyle=\footnotesize\ttfamily]
const emptySegment: TrackSegment = [];
const emptyTrack: Track = {
  activityId: '',
  segments: [emptySegment],
};
const useTracker = (interval: number = 2000): TrackRecorder => {
  const { enableNoSleep, disableNoSleep } = useNoSleep();
  const { startWatchingPosition, stopWatchingPosition, latestPosition, isWatchingPosition } = useGeolocation();
  const [isTracking, setIsTracking] = useState<boolean>(false);
  const [track, setTrack] = useState<Track>(emptyTrack);
  useInterval(
    () => {
      updateTrack();
    },
    isTracking ? interval : null
  );
  const updateTrack = () => {
    if (!latestPosition) {
      if (track.segments[track.segments.length - 1].length !== 0) {
        setTrack({ ...track, segments: [...track.segments, emptySegment] })
      }
      return;
    }
    const newTrackPoint: TrackPoint = {
      lat: latestPosition.coords.latitude,
      lon: latestPosition.coords.longitude,
      ele: latestPosition.coords.altitude || null,
      time: Date.now(),
    };
    const newTrack = { ...track, segments: [...track.segments] };
    newTrack.segments[newTrack.segments.length - 1].push(newTrackPoint);
    setTrack(newTrack);
  };
  const startTracking = (): void => {
    if (isTracking) { return;}
    if (!isWatchingPosition) {
      startWatchingPosition();
    }
    setTrack(emptyTrack);
    setIsTracking(true);
    enableNoSleep();
  };
  const stopTracking = (): void => {
    if (!isTracking) { return; }
    setIsTracking(false);
    disableNoSleep();
  };
  return {
    track, startTracking, stopTracking, isTracking, ...geolocation,
  };
};
\end{lstlisting}

Dla lepszego zobrazowania dzia³ania funkcji \texttt{updateTrack}, na rysunku~\ref{fig:trackerpage} przedstawiono diagram sekwencji funkcji. W pseudokodzie na schemacie przyjêto nastêpuj¹ce oznaczenia:
\begin{itemize}
  \item \texttt{{[last]}} w zapisie \texttt{track.segments{[last]}} oznacza odwo³anie to ostatniego elementu w tablicy.
  \item Metoda \texttt{.isEmpty()} zwraca \texttt{true}, je¿eli tablica jest pusta, \texttt{false} w przeciwnym razie.
  \item Metoda \texttt{.push()} dodaje nowy element na koniec tablicy.
  \item Metoda \texttt{.mapToTrackPoint()} oznacza zmapowanie obiektu \texttt{GeolocationPosition} na obiekt \texttt{TrackPoint}.
\end{itemize}

Obiekt \texttt{track} jest zwracany do komponentu \texttt{TrackerPage}, a nastêpnie przekazywany do wyœwietlenia do komponentu \texttt{Map}. Ponadto \texttt{track} jest równie¿ przekazywany do \emph{hooka} \texttt{useActivityStatistics}. Dokonuje on wyliczeñ statystyk i zwraca obiekt statystyk, który prezentowany jest przez komponent \texttt{StatisticsDashboard}.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.75\linewidth]{rys03/updatetrack}
  \caption{Diagram sekwencji dla funkcji \texttt{updateTrack} }
  \label{fig:trackerpage}
\end{figure}

\section{Implementacja kalkulatora statystyk œladu}
Kalkulator statystyk zaimplementowano w \emph{hooku} \texttt{useActivityStatistics}. \emph{Hook} zwraca obiekt statystyk który zawiera: ostatni¹ (najnowsz¹) oraz maksymaln¹ uzyskan¹ prêdkoœæ; ostatni¹ (najnowsz¹), minimaln¹ i maksymaln¹ wysokoœæ nad poziomem morza, sumê przewy¿szeñ przejechanych pod górê i z góry; ca³kowity przejechany dystans; ca³kowity czas podró¿y oraz czas podró¿y w ruchu.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:useactivitystatistics, caption=Kod \emph{hooka} \texttt{useActivityStatistics}, basicstyle=\footnotesize\ttfamily]
export type ActivityStatisticsExtended = {
  latestSpeed?: number; latestElevation?: number;
} & ActivityStatistics;
const useActivityStatistics = (track: Track): ActivityStatisticsExtended => {
  const [latestSpeed, setLatestSpeed] = useState<number>();
  const [latestElevation, setLatestElevation] = useState<number>();
  const [totalDistance, setTotalDistance] = useState<number>();
  const [totalDuration, setTotalDuration] = useState<number>();
  const [inMotionDuration, setInMotionDuration] = useState<number>();
  const [maxSpeed, setMaxSpeed] = useState<number>();
  const [elevationUp, setElevationUp] = useState<number>();
  const [elevationDown, setElevationDown] = useState<number>();
  useEffect(() => {
    const s = calculateStatistics(track);
    setMaxSpeed(s.maxSpeed);
    setLatestSpeed(s.latestSpeed);
    setLatestElevation(s.latestElevation);
    setTotalDuration(s.totalDuration);
    setTotalDistance(s.totalDistance);
    setInMotionDuration(s.inMotionDuration);
    setElevationUp(s.elevationUp);
    setElevationDown(s.elevationDown);
  }, [track]);
  return { latestSpeed, latestElevation, totalDistance, totalDuration, inMotionDuration, maxSpeed, elevationUp, elevationDown };
};
\end{lstlisting}

Kod \emph{hooka} przedstawiono na lisitngu~\ref{lst:useactivitystatistics}. Dla ka¿dej statystyki zaimplementowano osobny stan, a wszystkie stany zwracane s¹ z \emph{hooka} w jednym obiekcie. Przy ka¿dej modyfikacji obiektu \texttt{track} wywo³ywana jest funkcja \texttt{calculateStatistics(track)} która wylicza wszystkie statystyki. Z racji, ¿e funkcja jest obszerna, jej kodu nie zawarto na ¿adnym listingu. Natomiast algorytm jej dzia³ania opisuje nastêpuj¹cy pseudokod:
\begin{enumerate}
  \item Zainicjalizuj zmienne wartoœci¹ zerow¹:
        \texttt{latestElevation}
        \texttt{totalDuration}
        \texttt{latestSpeed}
        \texttt{maxSpeed}
        \texttt{totalDistance}
        \texttt{inMotionDuration}
        \texttt{elevationUp}
        \texttt{elevationDown}
        \texttt{minElevation}
        \texttt{maxElevation}.
  \item Wykonaj \texttt{trackFlat = track.segments.flat()} --- sp³aszcz tablicê wielowymiarow¹ do tablicy jednowymiarowej.
  \item Je¿eli tablica \texttt{trackFlat} jest pusta, idŸ do \emph{11}. W przeciwnym razie idŸ do \emph{3}.
  \item Zainicjalizuj \texttt{ftp} jako pierwszy obiekt z \texttt{trackFlat}.
  \item Zainicjalizuj \texttt{ltp} jako ostatni obiekt z \texttt{trackFlat}.
  \item Przypisz \texttt{latestElevation} jako \texttt{ftp.ele}.
  \item Przypisz \texttt{minElevation} jako \texttt{ftp.ele}.
  \item Przypisz \texttt{maxElevation} jako \texttt{ftp.ele}.
  \item Je¿eli \texttt{trackFlat.length >= 2}, oblicz i przypisz \texttt{latestSpeed} = \texttt{geoSpeed(\emph{ostatni element trackFlat, przedostatni element trackFlat})}.
  \item Dla ka¿dego elementu \texttt{currTrackPoint} oraz \texttt{prevTrackPoint} takiego, ¿e \texttt{prevTrackPoint} jest bezpoœrednim poprzednikiem \texttt{currTrackPoint}:
        \begin{enumerate}
          \item Oblicz i przypisz \texttt{\{distance, speed, time, deltaElevation\} = geoMove(currTrackPoint, prevTrackPoint)}.
          \item Je¿eli \texttt{speed>0}, idŸ do \emph{10.3}. W przeciwnym razie idŸ do \emph{10.1} kolejnej iteracji.
          \item Przypisz \texttt{totalDistance += distance}.
          \item Przypisz \texttt{inMotionDuration += time}.
          \item Je¿eli \texttt{speed} jest wiêksze od \texttt{maxSpeed}, to przypisz: \texttt{maxSpeed = speed}.
          \item Je¿eli \texttt{dElevation > 0}, to przypisz \texttt{elevationDown += dElevation}. W przeciwnym razie przypisz \texttt{elevationUp += -dElevation}
          \item Je¿eli \texttt{currTrackPoint.ele} jest wiêksze od \texttt{maxElevation}, to przypisz \texttt{maxElevation = currTrackPoint.ele}
          \item Je¿eli \texttt{currTrackPoint.ele} jest mniejsze od \texttt{minElevation}, to przypisz \texttt{minElevation = currTrackPoint.ele}
        \end{enumerate}
  \item Zwróæ obiekt z danymi: \{\texttt{latestElevation},
        \texttt{totalDuration},
        \texttt{latestSpeed},
        \texttt{maxSpeed},
        \texttt{totalDistance},
        \texttt{inMotionDuration},
        \texttt{elevationUp},
        \texttt{elevationDown},
        \texttt{minElevation},
        \texttt{maxElevation}\}.
\end{enumerate}

Kod funkcji \texttt{geoMove} pokazano na listingu~\ref{lst:geomove}. Korzysta ona z funkcji pomocniczych \texttt{geoDistance}, \texttt{deltaTime}, \texttt{geoSpeed1}, \texttt{deltaElevation}, które dokonuj¹ odpowiednich obliczeñ. Szczególnie interesuj¹ca jest funkcja \texttt{geoDistance}, która korzysta z formu³y \emph{Harvesine}~\cite{harvesine}. Odpowiedni kod przedstawiono na listingu~\ref{lst:geodistance}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:geomove, caption=Kod \emph{hooka} \texttt{useActivityStatistics}, basicstyle=\footnotesize\ttfamily]
export const geoMove = (
  lat1: number, lon1: number, time1: number, lat2: number, lon2: number, time2: number, ele1?: number | null, ele2?: number | null
): {
  distance: number; speed: number; time: number; dElevation: number | undefined;
} => {
  const distance = geoDistance(lat1, lon1, lat2, lon2); // m
  const time = deltaTime(time1, time2); // ms
  const speed = geoSpeed1(distance, time); // m/s
  const dElevation = deltaElevation(ele1, ele2); // m
  return { distance, speed, time, dElevation };
};
\end{lstlisting}

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:geodistance, caption=Kod \emph{hooka} \texttt{useActivityStatistics}, basicstyle=\footnotesize\ttfamily]
export const toRad = (value: number) => {
  return (value * Math.PI) / 180;
};
export const geoDistance = (
  lat1: number, lon1: number, lat2: number, lon2: number
) => {
  const R = 6371 * 1000; // Radius of the earth in m
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c; // m
};
\end{lstlisting}


% \section{Implementacja importu œladów GPS}

% \section{Implementacja eksportu œladów GPS}

% \section{Implementacja aktywnoœci}

% \section{Integracja z \texttt{Realtime Database}}

% \section{Implementacja profilu u¿ytkownika}

% \section{Implementacja kalkulatora statystyk profilu}
