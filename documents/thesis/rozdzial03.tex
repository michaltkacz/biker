\chapter{Implementacja projektu}
\label{chap:implementacja}
W niniejszym rozdziale przedstawiono proces tworzenia aplikacji. Pokazano fragmenty kodu realizuj¹ce kluczowe funkcjonalnoœci, jak np.:~uwierzytelnianie, rejestrowanie œladów czy prezentacja statystyk. Zawarto równie¿ rysunki, na których ukazane s¹ widoki aplikacji.

Przebieg procesu implementacji projektu mo¿na podzieliæ na etapy, których kolejnoœæ przedstawiono poni¿ej. Jednak w praktyce prace nad pewnymi etapami prowadzono równolegle, jak np.:~nagrywanie œladów oraz kalkulator statystyk. Wynika to naturalnie z faktu, ¿e pewne etapy s¹ ze sob¹ œciœlej powi¹zane, a co za tym idzie --- zmiany wprowadzone w jednej czêœci systemu, poci¹gaj¹ za sob¹ zmiany w drugiej czêœci systemu.
\begin{enumerate}
  \item Inicjalizacja aplikacji klienta.
  \item Inicjalizacja \texttt{Firebase}.
  \item Integracja z \texttt{Firebase}.
  \item Integracja z \texttt{Firebase Hosting}.
  \item Konfiguracja PWA.
  \item Projekt struktury bazy danych.
  \item Implementacja uk³adów stron.
  \item Implementacja uwierzytelniania.
  \item Implementacja routingu.
  \item Implementacja rejestratora GPS.
  \item Implementacja importu GPX.
  \item Implementacja eksportu GPX.
  \item Implementacja aktywnoœci.
  \item Implementacja statystyk aktywnoœci.
  \item Implementacja wykresów aktywnoœci.
  \item Integracja z \texttt{Realtime Database}.
  \item Implementacja profilu u¿ytkownika.
  \item Implementacja statystyk profilu u¿ytkownika.
  \item Implementacja wykresów profilu u¿ytkownika.
\end{enumerate}

Pracê nad projektem prowadzono z u¿yciem edytora \texttt{Visual Studio Code}. Zmiany w kodzie regularnie zapisywano do zdalnego repozytorium \texttt{GitHub}. Repozytorium jest publiczne, a~dostêp do niego mo¿na uzyskaæ pod adresem:~\url{https://github.com/michaltkacz/biker}.

\section{Inicjalizacja aplikacji klienta}
Projekt aplikacji klienta utworzono przez uruchomienie komendy w œrodowisku \texttt{Node.js}, przedstawionej na listingu~\ref{lst:npx}. Dziêki wykorzystaniu flagi \texttt{--template cra-template-pwa-typescript} projekt zainicjalizowano w konfiguracji z jêzykiem \texttt{TypeScript} oraz z zaimplementowanym \emph{service-workerem} odpowiedzialnym za dzia³anie aplikacji w trybie PWA. Nastêpnie projekt oczyszczono ze zbêdnych plików oraz zainstalowano kluczowe, dodatkowe biblioteki (ponownie listing~\ref{lst:npx}) konieczne do rozpoczêcia pracy nad kodem (pozosta³e biblioteki w miarê zapotrzebowania doinstalowywano w póŸniejszych etapach rozwoju aplikacji). Finaln¹ strukturê plików uzyskan¹ po ukoñczeniu projektu przedstawiono w dodatku~\ref{chap:b}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[label=lst:npx, caption=Inicjalizacja projektu React oraz instalacja kluczowych bibliotek, basicstyle=\footnotesize\ttfamily]
npx create-react-app react-pwa-ts --template cra-template-pwa-typescript
cd react-pwa-ts
npm i react-router
npm i antd
npm i firebase
npm i firebaseui
npm i firebaseui
npm i craco
npm i craco-less
npm i leaflet
npm i react-leaflet
npm i react-icons
\end{lstlisting}
}

\begin{figure}[htb]
  \centering
  \begin{tabular}{@{}ll@{}}
    a)                                                                                     & b) \\
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.375\textwidth]{rys03/filetree1.png}}}} &
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.375\textwidth]{rys03/filetree2.png}}}}
  \end{tabular}
  \caption{Drzewo plików projektu: a) po inicjalizacji, b) po usuniêciu zbêdnych plików}
  \label{fig:filetree}
\end{figure}


\section{Inicjalizacja \texttt{Firebase}}
W celu inicjalizacji projektu Firebase nale¿y odwiedziæ stronê: \url{https://firebase.google.com/}, a nastêpnie postêpowaæ zgodnie z instrukcjami wyœwietlanymi na stronie, lub zgodnie z oficjaln¹ dokumentacj¹~\cite{fireinit}. Po pomyœlnej inicjalizacji, deweloper zyskuje dostêp do konsoli (\texttt{Firebase Console}) (rys.~\ref{fig:fireconsole}), która pozwala na zarz¹dzanie projektem. W menu po lewej stronie, w zak³adce \emph{Build} dostêpne s¹ poszczególne modu³y. Trzy z nich: \texttt{Authentication}, \texttt{Realtime Database} i \texttt{Hosting}, omówiono w dalszej czêœci~rozdzia³u.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\linewidth]{rys03/fireconsole.png}
  \caption{Widok g³ównej strony \texttt{Firebase Console}}
  \label{fig:fireconsole}
\end{figure}

\section{Integracja z \texttt{Firebase}}
W folderze z plikami Ÿród³owymi projektu aplikacji klienta utworzono nowy plik o nazwie \texttt{firebase.tsx}. Nastêpnie zawarto w nim kod konfiguracji \texttt{Firebase}, który skopiowano z~konsoli (rys.~\ref{fig:fireconfig}). Na podstawie tej konfiguracji, w pliku \texttt{src/firebase/firebase.tsx} zainicjalizowano modu³ aplikacji \texttt{Firebase}. W póŸniejszych etapach zainicjalizowano równie¿ obiekty autoryzacji \texttt{auth} oraz bazy danych \texttt{database}. Pozwalaj¹ one z poziomu aplikacji klienta odwo³ywaæ siê do odpowiednich funkcjonalnoœci po stronie \texttt{Firebase'a}. Finaln¹ wersjê pliku przedstawiono na listingu~\ref{lst:fireinit}

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{rys03/fireconfig.png}
  \caption{Obiekt konfiguracyjny w \texttt{Firebase Console}}
  \label{fig:fireconfig}
\end{figure}

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript,style=JavaScriptStyle, label=lst:fireinit, caption=Integracja aplikacji klienta z projektem \texttt{Firebase}, basicstyle=\footnotesize\ttfamily]
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getDatabase } from 'firebase/database';

const firebaseConfig = {
  apiKey: 'AIzaSyASclbvuJjuN5f1tSCixm9swsIvTeH9ZQk',
  authDomain: 'biker-784a8.firebaseapp.com',
  projectId: 'biker-784a8',
  databaseURL:
    'https://biker-784a8-default-rtdb.europe-west1.firebasedatabase.app/',
  storageBucket: 'biker-784a8.appspot.com',
  messagingSenderId: '993843027751',
  appId: '1:993843027751:web:dc5f8671671126b4501302',
};

const firebaseApp = initializeApp(firebaseConfig);

export const auth = getAuth(firebaseApp);
export const database = getDatabase(firebaseApp);

export default firebaseApp;
\end{lstlisting}
}

Zawartoœæ obiektu konfiguracyjnego jest unikalna dla danego projektu, jednak nie jest ona sekretna. W celu zabezpieczenia danych przechowywanych w bazie, nale¿y wykorzystaæ \texttt{Firebase Security Rules}. Regu³y bezpieczeñstwa zastosowane w projekcie omówiono w~dalszej czêœci rozdzia³u. Wiêcej informacji na temat obiektu konfiguracyjnego mo¿na znaleŸæ w dokumentacji~\cite{fireconfig}


\section{Integracja z \texttt{Firebase Hosting}}
Integracjê z us³ug¹ hostingu przeprowadzono wed³ug dokumentacji~\cite{firehosting}. W pierwszym kroku, w~katalogu g³ównym projektu, z poziomu wiersza poleceñ wykonano komendê \texttt{firebase init hosting}. Uruchamia ona intuicyjny konfigurator, który w kilku krokach pozwala skonfigurowaæ projekt do us³ugi hostowania. Po zakoñczeniu konfiguracji w katalogu g³ównym projektu powsta³y dwa pliki:~\texttt{.firebaserc} oraz \texttt{firebase.json}, których zawartoœæ pokazano odpowiednio na listingu~\ref{lst:firerc} i listingu~\ref{lst:firejson}. Pierwszy z nich to konfiguracja aliasów projektu. Jest to u¿yteczne w przypadku, gdy w jednym projekcie u¿ywanych jest wiele projektów \texttt{Firebase}. Drugi plik, to konfiguracja us³ugi hostingu. Dziêki niemu mo¿na ustawiæ takie opcje hostingu, jak np.:~przekierowania URL, nadpisania URL, czy nawet wyœwietlanie ukoœnika na koñcu adresu URL~(\emph{trailing-slash}).

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[style=json-style, label=lst:firerc, caption=Plik \texttt{.firebaserc}, basicstyle=\footnotesize\ttfamily]
{
  "projects": {
    "default": "biker-784a8"
  }
}
\end{lstlisting}
  }

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[style=json-style, label=lst:firejson, caption=Plik \texttt{firebase.json}, basicstyle=\footnotesize\ttfamily]
{
  "hosting": {
    "site": "biker-784a8",
    "public": "build",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}
\end{lstlisting}
  }

W kolejnym kroku zbudowano aplikacjê klienta z u¿yciem polecenia \texttt{npm run build}, a nastêpnie wywo³ano polecenie \texttt{firebase hosting deploy}. W wyniku tej procedury, zbudowan¹ aplikacjê opublikowano pod adresami: \url{biker-784a8.web.app} oraz \url{biker-784a8.firebaseapp.com}. Po wprowadzeniu zmian w projekcie, w celu aktualizacji hostowanej aplikacji, proces budowania i publikacji nale¿y powtórzyæ.

\section{Konfiguracja PWA}
W celu aktywacji opcji instalacji aplikacji jako PWA, oprócz rejestracji \emph{service-workera}, konieczna jest konfiguracja ustawieñ przy pomocy pliku \texttt{public/manifest.json}. Dokumentacja dostêpna jest pod adresem \cite{pwamanifest}. Finaln¹ wersjê manifestu przedstawiono na listingu~\ref{lst:pwamanifest}, a~jego wyjaœnienie zawarto w tabeli~\ref{tab:pwamanifest}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[style=json-style, label=lst:pwamanifest, caption=Plik \texttt{manifest.json}, basicstyle=\footnotesize\ttfamily]
{
  "background_color": "white",
  "categories": ["sport"],
  "description": "Cycling Navigation. Monitor all your cycling statistics in one place.",
  "dir": "ltr",
  "display": "standalone",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64",
      "type": "image/x-icon"
    },
    {
      "src": "logo.svg",
      "sizes": "any",
      "type": "image/svg+xml"
    },
    {
      "src": "logo_maskable.svg",
      "sizes": "any",
      "type": "image/svg+xml",
      "purpose": "maskable"
    }
  ],
  "lang": "en-US",
  "name": "Biker",
  "orientation": "portrait",
  "short_name": "Biker",
  "start_url": "/",
  "theme_color": "white"
}
\end{lstlisting}
}

\begin{table}[htb] \small
  \centering
  \caption{Opis pliku \texttt{manifest.json}}
  \label{tab:pwamanifest}
  \begin{tabularx}{\linewidth}{|l|X|} \hline
    Atrybut                                           & Opis                                              \\      \hline\hline
    \texttt{background\_color}, \texttt{theme\_color} & Kolor t³a oraz kolor motywu aplikacji             \\      \hline
    \texttt{categories}                               & Kategoria, do której nale¿y aplikacja             \\      \hline
    \texttt{description}                              & Opis aplikacji                                    \\      \hline
    \texttt{dir}, \texttt{lang}                       & Kierunek tekstu oraz jêzyk wyœwietlania aplikacji \\      \hline
    \texttt{display}, \texttt{orientation}            & Tryb wyœwietlania aplikacji oraz jej orientacja   \\      \hline
    \texttt{icons}                                    & Zestaw ikon aplikacji                             \\      \hline
    \texttt{name}, \texttt{short\_name}               & Nazwa oraz skrócona nazwa aplikacji               \\      \hline
    \texttt{start\_url}                               & Adres URL punktu wejœcia do aplikacji             \\      \hline
  \end{tabularx}
\end{table}

Ikony aplikacji (rys.~\ref{fig:pwaicons}) --- \texttt{logo.svg}, \texttt{logo\_maskable.svg}, \texttt{favicon.ico} --- zosta³y wykonane w programie do tworzenia grafiki wektorowej \texttt{Inkscape}. Ikony \texttt{favicon.ico} oraz \texttt{logo\_maskable.svg} ró¿ni¹ siê jedynie rozmiarem marginesu symbolu.

\begin{figure}[htb]
  \centering
  \begin{tabular}{@{}ll@{}}
    a)                                                                                & b) \\
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.475\textwidth]{rys03/logo.png}}}} &
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.475\textwidth]{rys03/logo_maskable.png}}}}
  \end{tabular}
  \caption{Ikony aplikacji: a) logo, b) logo\_maskable}
  \label{fig:pwaicons}
\end{figure}


\section{Projekt struktury bazy danych}
Korzystaj¹c z mo¿liwoœci jêzyka TypeScript, w projekcie utworzono typy danych definiuj¹ce po stronie klienta strukturê bazy danych. Typy te s¹ reprezentacj¹ drzewa obiektów przedstawionego na rysunku~\ref{lst:database}. Wykorzystanie sztywno zdefiniowanych typów gwarantuje spójnoœæ danych na przestrzeni ca³ej aplikacji oraz u³atwia integracjê z baz¹ danych po stronie \texttt{Firebase'a}. Dodatkow¹ zalet¹ jest ³atwiejsza kontrola b³êdów oraz unikniêcie nieprzewidzianego zachowania aplikacji. Zawartoœæ lisingów~\ref{lst:dbtypes1}, \ref{lst:dbtypes2}, \ref{lst:dbtypes3}, \ref{lst:dbenums} odpowiada plikowi \texttt{src/database/schema.tsx}.

Na listingu~\ref{lst:dbtypes1} przedstawiono strukturê typów w ogólnym ujêciu. \texttt{DatabaseSchema} przek³ada siê na instancjê bazy danych po stronie \texttt{Realtime Database}. Zawartoœci¹ obiektu tego typu s¹ obiekty u¿ytkowników kluczowane unikalnym identyfikatorem u¿ytkownika (identyfikator jest generowany automatycznie przez \texttt{Firebase} przy rejestracji nowego konta). Ka¿dy obiekt u¿ytkownika zawiera swój identyfikator, obiekt profilu, obiekt aktywnoœci i obiekt œladów. W obiekcie profilu z kolei przechowywane s¹ dane personalne u¿ytkownika: p³eæ, data urodzenia, waga, wzrost, kraj i miasto zamieszkania oraz opis.

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:dbtypes1, caption=Typy obiektowe struktury bazy danych (1/3) --- \emph{root} bazy danych oraz u¿ytkownik, basicstyle=\footnotesize\ttfamily]
type DatabaseSchema = {
  users?: { [userId: string]: User };
};
export type User = {
  userId: string;
  profile?: UserProfile;
  activities?: { [activityId: string]: Activity };
  tracks?: { [trackId: string]: Track };
  };
export type UserProfile = {
  gender?: GenderTypes;
  birthday?: string;
  weight?: number;
  height?: number;
  country?: string;
  city?: string;
  description?: string;
};
\end{lstlisting}
  }

Na listingu~\ref{lst:dbtypes2} pokazano typ aktywnoœci, która zawiera w sobie szczegó³owe dane o zapisanej podró¿y rowerowej, w tym podstawowe statystki œladu. Wœród statystyk nie ma zapisanych ¿adnych wartoœci uœrednionych (np.:~œrednia prêdkoœæ, œrednia elewacja), poniewa¿ mo¿na je ³atwo wyliczyæ z pozosta³ych, dostêpnych statystyk.

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:dbtypes2, caption=Typy obiektowe struktury bazy danych (2/3) --- aktywnoœci, basicstyle=\footnotesize\ttfamily]
export type Activity = {
  activityId: string;
  creatorId: string;
  name: string;
  createdAt: number;
  lastModifiedAt: number;
  startTime: number;
  endTime: number;
  sport: ActivitySportTypes;
  category: ActivityCategoryTypes;
  shape: ActivityShape;
  statistics: ActivityStatistics;
  rating?: RatingTypes;
  tags?: Array<string>;
};
export type ActivityShape = {
  isLoop: boolean;
  from: string;
  to: string;
};
export type ActivityStatistics = {
  totalDistance?: number;
  totalDuration?: number;
  inMotionDuration?: number;
  maxSpeed?: number;
  elevationUp?: number;
  elevationDown?: number;
  minElevation?: number;
  maxElevation?: number;
};
\end{lstlisting}
  }

Typy \texttt{Track}, \texttt{TrackSegment} i \texttt{TrackPoint} zdefiniowano na wzór standardu GPX --- odpowiednio \texttt{trkType}, \texttt{trksegType} i \texttt{ptType}. Zatem obiekt œladu sk³ada siê z listy segmentów oraz dodatkowo z identyfikatora aktywnoœci, do której nale¿y. Z kolei jeden segment, to lista punktów, które opisuj¹ szerokoœæ i d³ugoœæ geograficzn¹, czas zarejestrowania po³o¿enia oraz ewentualn¹ bezwzglêdn¹ wysokoœæ nad poziomem morza. Definicje typów zawarto w~listingu~\ref{lst:dbtypes3}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:dbtypes3, caption=Typy obiektowe struktury bazy danych (3/3) ---  œlady, basicstyle=\footnotesize\ttfamily]
export type Track = {
  activityId: string;
  segments: Array<TrackSegment>;
};
export type TrackSegment = Array<TrackPoint>;
export type TrackPoint = {
  lat: number;
  lon: number;
  time: number;
  ele?: number | null;
};
\end{lstlisting}
}

Oprócz typów obiektowych zdefiniowano równie¿ cztery typy wyliczeniowe, które przedstawiono na listingu~\ref{lst:dbenums}. Okreœlaj¹ one dostêpne dla u¿ytkownika opcje wyboru dla danych: p³eæ u¿ytkownika, rodzaj sportu aktywnoœci, kategoria aktywnoœci oraz ocena aktywnoœci.

\begingroup
\listingcaption{Typy wyliczeniowe struktury bazy danych}
\setlength\multicolsep{0pt plus 2pt}%
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, multicols=2, label=lst:dbenums]
export enum GenderTypes {
  Male = 'male',
  Female = 'female',
  Other = 'other',
}
export enum ActivitySportTypes {
  Touring = 'touring',
  MTB = 'mtb',
  Enduro = 'enduro',
  Downhill = 'downhill',
  Gravel = 'gravel',
  Road = 'road',
  BMX = 'bmx',
  Tandem = 'tandem',
  Cyclocross = 'cyclocross',
  Track = 'track',
  Speedway = 'speedway',
  Other = 'other',
}
export enum ActivityCategoryTypes {
  Commute = 'commute',
  Casual = 'casual',
  Workout = 'training',
  Race = 'race',
  Bikepacking = 'bikepacking',
  Other = 'other',
}
export enum RatingTypes {
  Terrible = 'terrible',
  Poor = 'poor',
  Fair = 'fair',
  Good = 'good',
  Excellent = 'excellent',
}
\end{lstlisting}
\vspace{6pt plus 2pt}
\endgroup

\section{Implementacja uk³adów stron}
W aplikacji zaimplementowano dwa ró¿ne uk³ady strony --- jeden wy³¹cznie dla strony autoryzacji, a drugi -- globalny, wspólny dla wszystkich pozosta³ych stron. Uk³ady s¹ w pe³ni responsywne, co oznacza, ¿e dynamicznie dostosowuj¹ siê one do rozmiaru ekranu urz¹dzenia. Responsywnoœæ uzyskano dziêki zastosowaniu zasad CSS typu \texttt{@media min-width}.

Szablon uk³adu strony autoryzacji przedstawiaj¹: w wersji desktopowej (dla ekranu o szerokoœci powy¿ej 768px)--- rysunek~\ref{fig:authpagetemplatedesktop}, a w wersji mobilnej --- rysunek~\ref{fig:authpagemobile}a (dla ekranu o szerokoœci nie przekraczaj¹cej 768px). Gotowe widoki aplikacji dla powy¿szych szablonów pokazano odpowiednio na rysunku~\ref{fig:authpagedesktop} oraz rysunku~\ref{fig:authpagemobile}b.

Szablon globalny (rys.~\ref{fig:globaltemplatepage}), wykorzystano do zbudowania stron: profilu u¿ytkownika, rejestratora GPS oraz aktywnoœci (rys.~\ref{fig:globalpage}). Jest on równie¿ w pe³ni responsywny. Dla ekranów o~rozmiarze powy¿ej 1200px \emph{sider} przyjmuje on sta³¹ szerokoœæ 200px i nie mo¿e zostaæ ukryty, natomiast \emph{content} wype³nia ca³e pozosta³e miejsce. W przypadku ekranów nie wiêkszych ni¿ 1200px, \emph{sider} staje siê dynamiczny --- mo¿e zostaæ ukryty przy u¿yciu przycisku \emph{sider button}. Z kolei \emph{content} przyjmuje sta³¹ szerokoœæ równ¹ ca³kowitej szerokoœci okna widoku. Z~tego wzglêdu otwarcie \emph{sidera} powoduje wypchniêcie \emph{contentu} o 200px w prawo, poza obszar ekranu. Jest to zabieg umyœlny, który ma na celu zminimalizowanie efektu \emph{content jumpingu}, czyli niechcianej zmiany po³o¿enia elementów strony. Efekt ten by³ szczególnie zauwa¿alny na urz¹dzeniach z w¹skim ekranem, jak np.:~smartfonach.

% \newpage
\begin{figure}[htp]
  \centering
  \includegraphics[width=\linewidth]{rys03/authpagetemplatedesktop}
  \caption{Szablon uk³adu strony autoryzacji w wersji desktopowej}
  \label{fig:authpagetemplatedesktop}
\end{figure}

\begin{figure}[htp]
  \centering
  \includegraphics[width=\linewidth]{rys03/authpagedesktop}
  \caption{Widok strony autoryzacji w wersji desktopowej}
  \label{fig:authpagedesktop}
\end{figure}

\begin{figure}[htp]
  \centering
  \begin{tabular}{@{}ll@{}}
    a)                                                                                              & b) \\
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.475\textwidth]{rys03/authpagetemplatemobile}}}} &
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.475\textwidth]{rys03/authpagemobile}}}}
  \end{tabular}
  \caption{Uk³ad strony autoryzacji a) szablon, b) widok aplikacji}
  \label{fig:authpagemobile}
\end{figure}

% \begin{figure}[ht]
%   \centering
%   \includegraphics[width=0.4\linewidth]{rys03/authpagetemplatemobile}
%   \caption{Szablon uk³adu strony autoryzacji w wersji mobilnej}
%   \label{fig:authpagetemplatemobile}
% \end{figure}

% \begin{figure}[ht]
%   \centering
%   \includegraphics[width=0.4\linewidth]{rys03/authpagemobile}
%   \caption{Widok strony autoryzacji w wersji mobilnej}
%   \label{fig:authpagemobile}
% \end{figure}

% \newpage
\begin{figure}[htp]
  \centering
  \includegraphics[width=\linewidth]{rys03/globaltemplatepage}
  \caption{Szablon globalnego uk³adu strony w wersji mobilnej i desktopowej}
  \label{fig:globaltemplatepage}
\end{figure}

\begin{figure}[htp]
  \centering
  \includegraphics[width=\linewidth]{rys03/globalpage}
  \caption{Widok strony aktywnoœci w wersji desktopowej}
  \label{fig:globalpage}
\end{figure}


\section{Implementacja uwierzytelniania}
Do implementacji uwierzytelniania wykorzystano modu³ \texttt{Firebase Authentication} oraz bibliotekê \texttt{FirebaseUI}. W pierwszym kroku, w pliku \texttt{src/firebase/firebase.tsx} zainicjalizowano modu³ autentykacji, jak pokazano na listingu~\ref{lst:fireinit}. Nastêpnie utworzono komponent \texttt{Auth} (jak pokazano na listingu~\ref{lst:authcomponent}), który przy pierwszym renderowaniu uruchamia us³ugê uwierzytelniania z biblioteki \texttt{FirebaseUI}. Funkcjê \texttt{startFirebaseUI} zaimplementowano w pliku \texttt{src/firebase/firebaseUI.tsx}, jej kod oraz konfiguracjê biblioteki przedstawiono na listingu~\ref{lst:firebaseui}. W wyniku dzia³ania funkcji, do kontenera o identyfikatorze \texttt{\#firebaseui-auth-container} wstrzykniêty zostaje komponent autoryzacji, który zgodnie podan¹ konfiguracj¹ umo¿liwia autoryzacjê dwiema metodami: przez podanie adresu email oraz has³a lub przez konto \texttt{Google}. Komponent widoczny jest na rysunku~\ref{fig:globalpage}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:authcomponent, caption=Komponent uwierzytelniania, basicstyle=\footnotesize\ttfamily]
const Auth: React.FC = () => {
  useEffect(() => {
    startFirebaseUI();
  }, []);
  return (
    <div className='auth'>
      <Typography.Title level={2} className='auth-title'>
        Sign In
      </Typography.Title>
      <div id={elementID} className='auth-widget'></div>
    </div>
  );
};
\end{lstlisting}
}

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:firebaseui, caption=Autoryzacja z u¿yciem biblioteki \texttt{FirebaseUI}, basicstyle=\footnotesize\ttfamily]
const firebaseUI = new firebaseui.auth.AuthUI(auth);
export const firebaseUiDefaultConfig: firebaseui.auth.Config = {
  signInFlow: 'popup',
  signInOptions: [
    EmailAuthProvider.PROVIDER_ID,
    GoogleAuthProvider.PROVIDER_ID,
  ],
  tosUrl: 'https://en.wikipedia.org/wiki/Terms_of_service',
  privacyPolicyUrl: 'https://en.wikipedia.org/wiki/Privacy_policy',
};
export const elementID: string = 'firebaseui-auth-container';
export const startFirebaseUI = () => {
  firebaseUI.start('#' + elementID, firebaseUiDefaultConfig);
};
\end{lstlisting}
}

Dane zalogowanego u¿ytkownika dostêpne s¹ w przestrzeni aplikacji dziêki wykorzystaniu kontekstu~\cite{reactcontext} o nazwie \texttt{AuthContext}, którego definicja znajduje siê w pliku \texttt{src/firebase/contexts/AuthContext.tsx}. Najwa¿niejsze jego funkcje przedstawiono na listingu~\ref{lst:authcontext}. Kluczowym dzia³aniem jest subskrypcja \texttt{onAuthStateChanged}, która nas³uchuje odpowiedzi ze strony \texttt{Firebase}. W przypadku pojawienia siê poprawnej odpowiedzi, otrzymywany jest obiekt u¿ytkownika. Nastêpnie obiekt ten jest zapisany jako \texttt{currentUser}. Wszystkie komponenty bêd¹ce potomkami (widoczne na listingu~\ref{lst:routing}) kontekstu posiadaj¹ dostêp do obiektu u¿ytkownika poprzez \emph{hook}~\cite{reacthooks} \texttt{useAuth}, zdefiniowany w~pliku \texttt{src/firebase/hooks/useAuth.tsx}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:authcontext, caption=Komponent kontekstu uwierzytelniania, basicstyle=\footnotesize\ttfamily]
export const AuthContext = createContext<IAuthContext | undefined>(undefined);
export const AuthContextProvider: React.FC = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  ...
  useEffect(() => {
    const unsubscribe = onAuthStateChanged(
      auth,
      (user) => {
        setCurrentUser(user);
        ...
      },
      (error) => {
        setCurrentUser(null);
        ...
      }
    );
    return unsubscribe;
  }, []);
  ...
  const logoutUser = (): void => {
    signOut(auth);
  };
  const currentUserId = currentUser ? currentUser.uid : null;
  const value: IAuthContext = {
    currentUser,
    currentUserId,
    updateUser,
    logoutUser,
  };
  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};
\end{lstlisting}
}

\section{Implementacja routingu}
Dynamiczny routing po stronie klienta zaimplementowano z wykorzystaniem biblioteki \texttt{React Router}. strukturê routingu pokazano na listingu~\ref{lst:routing}. Trasa do strony autoryzacji jest publiczna, natomiast trasy do stron: profilu, rejestratora GPS i aktywnoœci s¹ prywatne. W przypadku próby dostêpu do niezdefiniowanej trasy, nastêpuje przekierowanie na stronê \texttt{NotFoundPage}, która informuje u¿ytkownika, ¿e strona pod zadan¹ tras¹ nie istnieje.

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:routing, caption=Struktura aplikacji oraz routing aplikacji, basicstyle=\footnotesize\ttfamily]
  const App: React.FC = () => {
    return (
      <Router>
        <AuthContextProvider>
          <PageLayout>
            <Switch>
              <RoutePublic exact path={`/${Pages.Authorize}`}>
                <AuthPage />
              </RoutePublic>
              <RoutePrivate exact path={`/${Pages.Profile}`}>
                <ProfilePage />
              </RoutePrivate>
              <RoutePrivate exact path={`/${Pages.Tracker}`}>
                <TrackerPage />
              </RoutePrivate>
              <RoutePrivate exact path={`/${Pages.Activities}`}>
                <ActivitiesPage />
              </RoutePrivate>
              <Route path='/*' component={NotFoundPage} />
            </Switch>
          </PageLayout>
        </AuthContextProvider>
      </Router>
    );
  };
\end{lstlisting}
  }

Do tras publicznych maj¹ dostêp wszyscy u¿ytkownicy nieuwierzytelnieni. Komponent \texttt{PublicPrivate} przedstawiono na listingu~\ref{lst:privateroute}. Je¿eli trasê próbuje odwiedziæ u¿ytkownik uwierzytelniony, to nastêpuje przekierowanie na stronê profilu u¿ytkownika. Zabieg ten ma na celu zablokowanie dostêpu do strony autoryzacji w przypadku, gdy w aplikacji jest ju¿ zalogowany u¿ytkownik.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:privateroute, caption=Publiczna trasa routingu, basicstyle=\footnotesize\ttfamily]
const RoutePublic: React.FC<RouteProps> = ({ children, ...rest }) => {
  const { currentUser } = useAuth();
  return (
    <Route
      {...rest}
      render={() => (!currentUser ? children : <Redirect to={Pages.Profile} />)}
    />
  );
};
\end{lstlisting}
}

Trasa prywatna to taka, do której dostêp maj¹ jedynie u¿ytkownicy uwierzytelnieni. Komponent \texttt{RoutePrivate} przedstawiono na listingu~\ref{lst:privateroute}. Je¿eli w aplikacji jest uwierzytelniony u¿ytkownik, to zwracany jest docelowy komponent trasy. W przeciwnym razie nastêpuje przekierowanie na stronê uwierzytelniania.

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:privateroute, caption=Prywatna trasa routingu, basicstyle=\footnotesize\ttfamily]
const RoutePrivate: React.FC<RouteProps> = ({ children, ...rest }) => {
  const { currentUser } = useAuth();
  return (
    <Route
      {...rest}
      render={() =>
        currentUser ? children : <Redirect to={Pages.Authorize} />
      }
    />
  );
};
\end{lstlisting}
  }

\section{Implementacja rejestratora GPS}
Schemat komponentu strony rejestratora GPS przedstawiono na rysunku~\ref{fig:trackerpage}, a widok aplikacji na rysunku~\ref{fig:trackerpageview}. Komponent \texttt{TrackerPage} zwraca trzy komponenty:
\begin{enumerate}
  \item \texttt{Map} --- komponent mapy, odpowiedzialny za wyœwietlanie mapy, obecnej pozycji na mapie (w postaci markera) oraz œladu GPS w postaci linii ³amanej.
  \item \texttt{MapControls} --- komponent z przyciskami steruj¹cymi zachowaniem mapy (œledzenie pozycji i centrowanie widoku do obecnej pozycji) oraz z przyciskiem w³¹czaj¹cym lub wy³¹czaj¹cym rejestrator GPS.
  \item \texttt{MapDashboard} --- komponent wyœwietlaj¹cy statystki aktualnie nagrywanego œladu. Statystki wyliczane s¹ w \emph{hooku} \texttt{useActivityStatistics}.
\end{enumerate}

Kluczowa logika strony zawarta jest w \emph{hooku} \texttt{useTracker}, którego najwa¿niejszym zadaniem jest rejestrowanie œladu GPS. Kod programu realizuj¹cy to zadanie przedstawiono na listingu~\ref{lst:trackerpage}. Po w³¹czeniu nagrywania stan \texttt{track} ustawiany jest na wartoœæ bêd¹c¹ tablic¹ zawieraj¹c¹ jeden pusty segment (pust¹ tablicê punktów), a stan \texttt{isTracking} ustawiany jest na wartoœæ \texttt{true}, czego skutkiem jest aktywacja \emph{hooka} \texttt{useInterval}. Interwa³ wywo³uje funkcjê \texttt{updateTrack} co 2000ms.

Funkcja \texttt{updateTrack} najpierw sprawdza warunek, czy najnowsza pozycja jest dostêpna (w~przypadku b³êdu uzyskania lokalizacji przez przegl¹darkê, ostatnia pozycja przyjmuje wartoœæ \texttt{null}). Gdy pozycja jest niedostêpna i gdy ostatni segment \texttt{tracka} nie jest pusty, do \texttt{tracka}, na koniec tablicy dodawany jest nowy pusty segment. W przeciwnym wypadku --- gdy dostêpna jest nowa pozycja --- dopisywana jest ona na koñcu ostatniego segmentu \texttt{tracka}. Ponadto, aktywacja nagrywania blokuje wygaszacz ekranu urz¹dzenia (funkcje \texttt{enableNoSleep} \texttt{disableNoSleep} z \emph{hooka} \texttt{useNoSleep}).

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{rys03/trackerpage}
  \caption{Schemat strony rejestratora œladów GPS}
  \label{fig:trackerpage}
\end{figure}

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:trackerpage, caption=Strona rejestratora GPS, basicstyle=\footnotesize\ttfamily]
const emptySegment: TrackSegment = [];
const emptyTrack: Track = {
  activityId: '',
  segments: [emptySegment],
};
const useTracker = (interval: number = 2000): TrackRecorder => {
  const { enableNoSleep, disableNoSleep } = useNoSleep();
  const { startWatchingPosition, stopWatchingPosition, latestPosition, isWatchingPosition } = useGeolocation();
  const [isTracking, setIsTracking] = useState<boolean>(false);
  const [track, setTrack] = useState<Track>(emptyTrack);
  useInterval(
    () => {
      updateTrack();
    },
    isTracking ? interval : null
  );
  const updateTrack = () => {
    if (!latestPosition) {
      if (track.segments[track.segments.length - 1].length !== 0) {
        setTrack({ ...track, segments: [...track.segments, emptySegment] })
      }
      return;
    }
    const newTrackPoint: TrackPoint = {
      lat: latestPosition.coords.latitude,
      lon: latestPosition.coords.longitude,
      ele: latestPosition.coords.altitude || null,
      time: Date.now(),
    };
    const newTrack = { ...track, segments: [...track.segments] };
    newTrack.segments[newTrack.segments.length - 1].push(newTrackPoint);
    setTrack(newTrack);
  };
  const startTracking = (): void => {
    if (isTracking) { return;}
    if (!isWatchingPosition) {
      startWatchingPosition();
    }
    setTrack(emptyTrack);
    setIsTracking(true);
    enableNoSleep();
  };
  const stopTracking = (): void => {
    if (!isTracking) { return; }
    setIsTracking(false);
    disableNoSleep();
  };
  return {
    track, startTracking, stopTracking, isTracking, ...geolocation,
  };
};
\end{lstlisting}
}

Dla lepszego zobrazowania dzia³ania funkcji \texttt{updateTrack}, na rysunku~\ref{fig:trackerpage} przedstawiono diagram sekwencji funkcji. W pseudokodzie na schemacie przyjêto nastêpuj¹ce oznaczenia:
\begin{itemize}
  \item \texttt{{[last]}} w zapisie \texttt{track.segments{[last]}} oznacza odwo³anie to ostatniego elementu w~tablicy.
  \item Metoda \texttt{.isEmpty()} zwraca \texttt{true}, je¿eli tablica jest pusta, \texttt{false} w przeciwnym razie.
  \item Metoda \texttt{.push()} dodaje nowy element na koniec tablicy.
  \item Metoda \texttt{.mapToTrackPoint()} oznacza zmapowanie obiektu \texttt{GeolocationPosition} na obiekt \texttt{TrackPoint}  (definicja typu --- listing~\ref{lst:dbtypes3}).
\end{itemize}

Obiekt \texttt{track} jest zwracany do komponentu \texttt{TrackerPage}, a nastêpnie przekazywany do wyœwietlenia do komponentu \texttt{Map}. Ponadto \texttt{track} jest równie¿ przekazywany do \emph{hooka} \texttt{useActivityStatistics}. Dokonuje on wyliczeñ statystyk i zwraca obiekt statystyk, który prezentowany jest przez komponent \texttt{StatisticsDashboard}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.75\linewidth]{rys03/updatetrack}
  \caption{Diagram sekwencji dla funkcji \texttt{updateTrack}}
  \label{fig:trackerpage}
\end{figure}

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{rys03/tracker.png}
  \caption{Widok strony nagrywania rejestratora z w³¹czonym nagrywaniem œladu}
  \label{fig:trackerpageview}
\end{figure}

\section{Implementacja importu GPX}
Schemat procesu importu aktywnoœci z pliku GPX przedstawiono na rysunku~\ref{fig:importeksport}a. Na pocz¹tku u¿ytkownik wybiera z dysku urz¹dzenia pliki z rozszerzeniem \texttt{.gpx}. Nastêpnie pliki s¹ parsowane z wykorzystaniem biblioteki \texttt{gpxparser}. Rezultatem parsowania jest obiekt JavaScriptowy, który nastêpnie mapowany jest na obiekt typu \texttt{Activity} (definicja typu --- listing~\ref{lst:dbtypes2}) oraz wyliczane s¹ statystyki aktywnoœci. W przedostatnim kroku dane zapisywane s¹ do bazy, w wyniku czego aktywnoœci nadawany jest unikalny identyfikator. Na koniec aktywnoœæ wyœwietlana jest na stronie. Je¿eli na dowolnym etapie wyst¹pi b³¹d, proces importu jest~przerywany.

Kroki: parsowanie, mapowanie, obliczenie statystyk i zapis do bazy pokazano na listingu~\ref{lst:import}. Listing przedstawia kod \emph{hooka} \texttt{useEffect} komponentu \texttt{GpxToActivityParser}. Widok aplikacji z inferfejsem importu pokazano na rysunku~\ref{fig:globalpage}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:import, caption=Import aktywnoœci z pliku GPX, basicstyle=\footnotesize\ttfamily]
useEffect(() => {
  file.text().then((gpx) => {
    const gpxParser = new GpxParser();
    gpxParser.parse(gpx);
    let lastTime = 0;
    const newTrack: Track = {
      activityId: '',
      segments: gpxParser.tracks.map((parsedTrackSegment) => {
       const newTrackSegment: TrackSegment = parsedTrackSegment.points.map(
          (parsedTrackPoint) => {
            lastTime = parsedTrackPoint.time.getTime();
            const newTrackPoint: TrackPoint = {
              lat: parsedTrackPoint.lat,
              lon: parsedTrackPoint.lon,
              ele: parsedTrackPoint.ele,
              time: lastTime,
            };
            return newTrackPoint;
          }
        );
        return newTrackSegment;
      }),
    };
    const { latestSpeed, latestElevation, ...statistics } = calculateStatistics(newTrack);
    const newActivity: Activity = {
      activityId: '',
      creatorId: currentUserId || '',
      name: he.decode(gpxParser.metadata.name),
      createdAt: newTrack.segments[0][0].time,
      lastModifiedAt: Date.now(),
      startTime: newTrack.segments[0][0].time,
      endTime: lastTime,
      sport: ActivitySportTypes.Other,
      category: ActivityCategoryTypes.Other,
      shape: { isLoop: false, from: 'unknown', to: 'unknown' },
      statistics: statistics,
    };
    writeActivityWithTrack(currentUserId, newActivity, newTrack)
      .then(({ updatedActivity }) => {
        setActivity(updatedActivity);
        setError(false);
      })
      .catch(() => {
        setActivity(newActivity);
        setError(true);
      });
  }); }, [file, currentUserId]);
\end{lstlisting}}

\begin{figure}[h]
  \centering
  \begin{tabular}{@{}ll@{}}
    a)                                                                              & b) \\
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.33\textwidth]{rys03/import2}}}} &
    \vtop{\vskip-2ex\hbox{{\includegraphics[width=0.33\textwidth]{rys03/eksport2}}}}
  \end{tabular}
  \caption{Schematy procesów: a) importu aktywnoœci, b) eksportu aktywnoœci}
  \label{fig:importeksport}
\end{figure}

\section{Implementacja eksportu GPX}
\label{sec:eksport}
Schemat procesu eksportu aktywnoœci do pliku GPX przedstawiono na rysunku~\ref{fig:importeksport}b. W widoku aktywnoœci (rys.~\ref{fig:globalpage}) u¿ytkownik wybiera aktywnoœæ, która ma zostaæ wyeksportowana. Naciœniêcie przycisku \texttt{Export GPX} wywo³uje funkcjê \texttt{buildGpxAndSaveFile}, której kod przedstawiono na listingu~\ref{lst:eksport}. Funkcja przyjmuje dwa parametry: obiekt typu \texttt{Track} (definicja typu --- \ref{lst:dbtypes3}) oraz \texttt{filename}.

W pierwszym kroku w funkcji pomocniczej \texttt{buildGpx} obiekt \texttt{track} mapowany jest na tablicê obiektów typu \texttt{Point} zdefiniowanego w bibliotece \texttt{GPX builder}. Nastêpnie funkcja \texttt{buildGPX} generuje ³añcuch znaków, który jest reprezentacj¹ \texttt{tracka} w standardzie GPX. £añcuch znaków zapisywany jest do pliku z rozszerzeniem \texttt{*.gpx} funkcj¹ \texttt{saveAs} dostarczon¹ przez bibliotekê \texttt{file-saver}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:eksport, caption=Eksport aktywnoœci do pliku GPX, basicstyle=\footnotesize\ttfamily]
export const buildGpxAndSaveFile = (track: Track, fileName: string) => {
  const gpx = buildGpx(track);
  var blob = new Blob([gpx], {
    type: 'application/gpx+xml;charset=utf-8',
  });
  saveAs(blob, fileName + '.gpx');
};
export const buildGpx = (track: Track) => {
  const gpxData = new BaseBuilder();
  track.segments.forEach((segment) => {
    const points = segment.map(
      (point) =>
        new Point(point.lat, point.lon, {
          ele: point.ele || undefined,
          time: new Date(point.time),
        })
    );
    gpxData.setSegmentPoints(points);
  });
  return buildGPX(gpxData.toObject());
};
\end{lstlisting}}

\section{Implementacja aktywnoœci}
Strona aktywnoœci \texttt{ActivityPage} {rys.~\ref{fig:globalpage}} sk³ada siê z dwóch komponentów: importu aktywnoœci (umiejscowiony na górze strony) oraz listy zapisanych aktywnoœci. Ka¿dy element tej listy to komponent \texttt{Activity}. W komponencie tym prezentowane s¹ dane aktywnoœci, œlad GPS na mapie, statystyki aktywnoœci oraz wykresy aktywnoœci (rys.~\ref{fig:activitycharts}). Oprócz wyœwietlania danych dostêpne s¹ trzy funkcjonalnoœci: edycja danych aktywnoœci, usuniêcie aktywnoœci oraz eksport aktywnoœci. Kod funkcji przedstawiono na listingu~\ref{lst:activityfunctions}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:activityfunctions, caption={Funkcje: edycji, usuniêcia oraz eksportu aktywnoœci}, basicstyle=\footnotesize\ttfamily]
const onDeleteActivity = () => {
  deleteActivityWithTrack(currentUserId, activity.activityId)
    .then(() => {
      message.success('Activity deleted');
    })
    .catch(() => {
      message.error("Activity couldn't be deleted");
    });
};
const onUpdateActivity = () => {
  const payload: { [filed: string]: any } = {};
  payload['/lastModifiedAt'] = Date.now();
  updates.name && (payload['/name'] = name);
  updates.sport && (payload['/sport'] = sport);
  updates.category && (payload['/category'] = category);
  updates.shape && (payload['/shape'] = shape);
  updates.rating && (payload['/rating'] = rating || null);
  updates.tags && (payload['/tags'] = tags || null);
  updateActivity(currentUserId, activity.activityId, payload)
    .then(() => {
      message.success('Activity updated');
    })
    .catch(() => {
      message.error("Activity couldn't be updated");
    });
  setUpdates(ActivityNotUpdated);
  setActivityModified(false);
};
const onExportActivity = () => {
  if (!track) {
    message.error("Activity couldn't be exported");
    return;
  }
  buildGpxAndSaveFile(track, activity.name);
};
\end{lstlisting}}

Naciœniêcie przycisku \texttt{Delete} wywo³uje funkcjê \texttt{deleteActivityWithTrack}, która usuwa z bazy danych u¿ytkownika aktywnoœæ o zadanym identyfikatorze. Naciœniêcie przycisku \texttt{Update} (domyœlnie zablokowany, odblokowuje siê po wprowadzeniu zmiany w danych aktywnoœci) powoduje najpierw utworzenie obiektu \texttt{payload}, który zawiera listê zmian aktywnoœci, a nastêpnie wywo³anie funkcji \texttt{updateActivity}, która dokonuje aktualizacji w bazie danych u¿ytkownika. Funkcjê eksportu opisano w sekcji~\ref{sec:eksport}, a komunikacjê z baz¹ danych --- w~sekcji~\ref{sec:bazadanych}.

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{rys03/activitydatastats}
  \caption{Widok aktywnoœci}
  \label{fig:activitydatastats}
\end{figure}

\section{Implementacja statystyk aktywnoœci}
Funkcjonalnoœæ obliczania statystyk zaimplementowano w \emph{hooku} \texttt{useActivityStatistics}. \emph{Hook} zwraca obiekt statystyk, który zawiera nastêpuj¹ce dane:
\begin{itemize}
  \item \texttt{latestSpeed} --- ostatnia (najnowsza) prêdkoœæ;
  \item \texttt{maxSpeed} --- maksymalna prêdkoœæ;
  \item \texttt{latestElevation} --- ostatnia (najnowsza) wysokoœæ nad poziomem morza;
  \item \texttt{minElevation} --- minimalna wysokoœæ nad poziomem morza;
  \item \texttt{maxElevation} --- maksymalna wysokoœæ nad poziomem morza;
  \item \texttt{elevationUp} --- suma przewy¿szeñ pod górê;
  \item \texttt{elevationDown} --- suma przewy¿szeñ z góry;
  \item \texttt{totalDistance} --- ca³kowity przejechany dystans;
  \item \texttt{totalDuration} --- ca³kowity czas podró¿y;
  \item \texttt{inMotionDuration} --- czas podró¿y w ruchu.
\end{itemize}

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:useactivitystatistics, caption=\emph{Hook} \texttt{useActivityStatistics}, basicstyle=\footnotesize\ttfamily]
export type ActivityStatisticsExtended = {
  latestSpeed?: number; latestElevation?: number;
} & ActivityStatistics;
const useActivityStatistics = (track: Track): ActivityStatisticsExtended => {
  const [latestSpeed, setLatestSpeed] = useState<number>();
  const [latestElevation, setLatestElevation] = useState<number>();
  const [totalDistance, setTotalDistance] = useState<number>();
  const [totalDuration, setTotalDuration] = useState<number>();
  const [inMotionDuration, setInMotionDuration] = useState<number>();
  const [maxSpeed, setMaxSpeed] = useState<number>();
  const [elevationUp, setElevationUp] = useState<number>();
  const [elevationDown, setElevationDown] = useState<number>();
  const [minElevation, setMinElevation] = useState<number>();
  const [maxElevation, setMaxElevation] = useState<number>();
  useEffect(() => {
    const s = calculateStatistics(track);
    setMaxSpeed(s.maxSpeed);
    setLatestSpeed(s.latestSpeed);
    setLatestElevation(s.latestElevation);
    setTotalDuration(s.totalDuration);
    setTotalDistance(s.totalDistance);
    setInMotionDuration(s.inMotionDuration);
    setElevationUp(s.elevationUp);
    setElevationDown(s.elevationDown);
    setMinElevation(s.minElevation);
    setMaxElevation(s.maxElevation);
  }, [track]);
  return { latestSpeed, latestElevation, totalDistance, totalDuration, inMotionDuration, maxSpeed, elevationUp, elevationDown, minElevation, maxElevation };
};
\end{lstlisting}}

Kod \emph{hooka} przedstawiono na lisitngu~\ref{lst:useactivitystatistics}. Dla ka¿dej statystyki zaimplementowano osobny stan, a wszystkie stany zwracane s¹ z \emph{hooka} w jednym obiekcie. Przy ka¿dej modyfikacji obiektu \texttt{track} wywo³ywana jest funkcja \texttt{calculateStatistics(track)} która wylicza wszystkie statystyki. Z racji, ¿e funkcja jest obszerna, jej kodu nie zawarto na ¿adnym listingu. Natomiast algorytm jej dzia³ania opisuje nastêpuj¹cy pseudokod:
\begin{enumerate}
  \item Zainicjalizuj zmienne wartoœci¹ zerow¹:
        \texttt{latestElevation},
        \texttt{totalDuration},
        \texttt{latestSpeed},
        \texttt{maxSpeed},
        \texttt{totalDistance},
        \texttt{inMotionDuration},
        \texttt{elevationUp},
        \texttt{elevationDown},
        \texttt{minElevation},
        \texttt{maxElevation}.
  \item Wykonaj \texttt{trackFlat = track.segments.flat()} --- sp³aszcz tablicê wielowymiarow¹ do tablicy jednowymiarowej.
  \item Je¿eli tablica \texttt{trackFlat} jest pusta, idŸ do \emph{11}. W przeciwnym razie idŸ do \emph{3}.
  \item Zainicjalizuj \texttt{ftp} jako pierwszy obiekt z \texttt{trackFlat}.
  \item Zainicjalizuj \texttt{ltp} jako ostatni obiekt z \texttt{trackFlat}.
  \item Przypisz \texttt{latestElevation} jako \texttt{ftp.ele}.
  \item Przypisz \texttt{minElevation} jako \texttt{ftp.ele}.
  \item Przypisz \texttt{maxElevation} jako \texttt{ftp.ele}.
  \item Je¿eli \texttt{trackFlat.length >= 2}, oblicz i przypisz \texttt{latestSpeed} = \texttt{geoSpeed(\emph{ostatni element trackFlat, przedostatni element trackFlat})}.
  \item Dla ka¿dego elementu \texttt{currTrackPoint} oraz \texttt{prevTrackPoint} takiego, ¿e \texttt{prevTrackPoint} jest bezpoœrednim poprzednikiem \texttt{currTrackPoint}:
        \begin{enumerate}
          \item Oblicz i przypisz \texttt{\{distance, speed, time, deltaElevation\} = geoMove(currTrackPoint, prevTrackPoint)}.
          \item Je¿eli \texttt{speed>0}, idŸ do \emph{10.3}. W przeciwnym razie idŸ do \emph{10.1} kolejnej iteracji.
          \item Przypisz \texttt{totalDistance += distance}.
          \item Przypisz \texttt{inMotionDuration += time}.
          \item Je¿eli \texttt{speed} jest wiêksze od \texttt{maxSpeed}, to przypisz: \texttt{maxSpeed = speed}.
          \item Je¿eli \texttt{dElevation > 0}, to przypisz \texttt{elevationDown += dElevation}. W przeciwnym razie przypisz \texttt{elevationUp += -dElevation}
          \item Je¿eli \texttt{currTrackPoint.ele} jest wiêksze od \texttt{maxElevation}, to przypisz \texttt{maxElevation = currTrackPoint.ele}
          \item Je¿eli \texttt{currTrackPoint.ele} jest mniejsze od \texttt{minElevation}, to przypisz \texttt{minElevation = currTrackPoint.ele}
        \end{enumerate}
  \item Zwróæ obiekt z danymi:
        \{\texttt{latestElevation},
        \texttt{totalDuration},
        \texttt{latestSpeed},
        \texttt{maxSpeed},
        \texttt{totalDistance},
        \texttt{inMotionDuration},
        \texttt{elevationUp},
        \texttt{elevationDown},
        \texttt{minElevation},
        \texttt{maxElevation}\}.
\end{enumerate}

Kod funkcji \texttt{geoMove} pokazano na listingu~\ref{lst:geomove}. Korzysta ona z funkcji pomocniczych \texttt{geoDistance}, \texttt{deltaTime}, \texttt{geoSpeed1}, \texttt{deltaElevation}, które dokonuj¹ odpowiednich obliczeñ. Szczególnie interesuj¹ca jest funkcja \texttt{geoDistance}, która korzysta z formu³y \emph{Harvesine}~\cite{harvesine}. Jest to formu³a, która pozwala wyliczyæ najmniejsz¹ odleg³oœæ  miêdzy dwoma punktami na powierzchni sfery. Odpowiedni kod przedstawiono na listingu~\ref{lst:geodistance}. Funkcje \texttt{deltaTime}, \texttt{deltaElevation} sprowadzaj¹ siê do obliczenia jedynie ró¿nicy dwóch wartoœci (dla czasu zwracana jest wartoœæ bezwzglêdna), natomiast \texttt{geoSpeed1} implementuje formu³ê wyliczaj¹c¹ prêdkoœæ w ruchu jednostajnym (dystans ca³kowity dzielony przez czas ca³kowity).

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:geomove, caption=Funkcja \texttt{geoMove}, basicstyle=\footnotesize\ttfamily]
export const geoMove = (
  lat1: number, lon1: number, time1: number, lat2: number, lon2: number, time2: number, ele1?: number | null, ele2?: number | null
): {
  distance: number; speed: number; time: number; dElevation: number | undefined;
} => {
  const distance = geoDistance(lat1, lon1, lat2, lon2); // m
  const time = deltaTime(time1, time2); // ms
  const speed = geoSpeed1(distance, time); // m/s
  const dElevation = deltaElevation(ele1, ele2); // m
  return { distance, speed, time, dElevation };
};
\end{lstlisting}}

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:geodistance, caption=Funkcja \texttt{geoDistance}, basicstyle=\footnotesize\ttfamily]
export const toRad = (value: number) => {
  return (value * Math.PI) / 180;
};
export const geoDistance = (
  lat1: number, lon1: number, lat2: number, lon2: number
) => {
  const R = 6371 * 1000; // Radius of the earth in m
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRad(lat1)) *
      Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c; // m
};
\end{lstlisting}}

\section{Implementacja wykresów aktywnoœci}
Wykresy (rys.~\ref{fig:activitycharts}) wyœwietlane s¹ przez komponent \texttt{ActivityCharts}, który otrzymuje (jako w³aœciwoœæ) obiekt \texttt{track}. W pierwszej kolejnoœci jest on mapowany na serie danych obs³ugiwane przez wykresy z biblioteki \texttt{React-Vis}. W najprostszej wersji seria danych dla u¿ywanych wykresów typu \texttt{AreaChart} to tablica obiektów z dwoma kluczami:~\texttt{x} oraz {y}, odpowiadaj¹cymi wartoœciami odpowiednim osiom wykresu. Kod odpowiedzialny za mapowanie przedstawiono na listingu~\ref{lst:datachartmap}. Kompletna lista dostêpnych wykresów aktywnoœci jest nastêpuj¹ca:
\begin{itemize}
  \item wykres zale¿noœci prêdkoœci od czasu;
  \item wykres zale¿noœci pokonanego dystansu od czasu;
  \item wykres zale¿noœci bezwzglêdnej wysokoœci nad poziomem morza od czasu.
\end{itemize}

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:datachartmap, caption=Fragment funkcji generowania serii danch dla wykresów aktywnoœci, basicstyle=\footnotesize\ttfamily]
const parseData = async () => {
  ...
  flatTrack.forEach((point, index) => {
    const newElevation = Math.round(point.ele || 0);
    if (index !== 0) {
      const prevPoint = flatTrack[index - 1];
      const { distance, speed } = geoMove(
        point.lat,
        point.lon,
        point.time,
        prevPoint.lat,
        prevPoint.lon,
        prevPoint.time
      );
      newDistance += distance / 1000;
      newSpeed = speed * 3.6;
    }
    ...
    newDistanceData.push({ x: point.time, y: newDistance });
    newSpeedData.push({ x: point.time, y: newSpeed });
    newElevationData.push({
      x: point.time,
      y: newElevation,
    });
  });
  ...
};
\end{lstlisting}}

\begin{figure}[h]
  \centering
  \includegraphics[width=\linewidth]{rys03/activitycharts2}
  \caption{Widok wykresów aktywnoœci}
  \label{fig:activitycharts}
\end{figure}

\section{Integracja z \texttt{Realtime Database}}
\label{sec:bazadanych}
W celu integracji z baz¹ danych w pierwszym kroku nale¿y w aplikacji zainicjalizowaæ obiekt bazy danych, jak pokazano  na listingu~\ref{lst:fireinit} (obiekt \texttt{database}). Wszystkie funkcje odpowiedzialne za komunikacjê z baz¹ zaimplementowano w pliku \texttt{src/firebase/hooks/useDatabase.tsx}. Ponadto w pliku \texttt{src/firebase/contexts/AuthContext.tsx} zaimplementowano funkcjê \texttt{updateProfile}. Ró¿ni siê ona od pozosta³cyh funkcji tym, ¿e nie komunikuje siê bezpoœrednio z moud³em bazy danych, tylko z modu³em uwierzytelniania. Lista i opis zaimplementowanych funkcji przedstawiono w tabeli~\ref{tab:crudy}. Jest to minimalny i wystarczaj¹cy zestaw funkcji koniecznych do realizacji wszystkich wymagañ funkcjonalnych projektu.

\begin{table}[htb] \small
  \centering
  \caption{Komunikacja z baz¹ danych}
  \label{tab:crudy}
  \begin{tabularx}{\linewidth}{|l|l|l|X|} \hline
    Nazwa                            & Typ         & Operacja        & Opis                                                        \\\hline\hline
    \texttt{useReadActivities}       & \emph{hook} & \texttt{READ}   & Odczyt wszystkich aktywnoœci u¿ytkownika                    \\\hline
    \texttt{useReadTrack}            & \emph{hook} & \texttt{READ}   & Odczyt œladu GPX u¿ytkownika                                \\\hline
    \texttt{useReadProfile}          & \emph{hook} & \texttt{READ}   & Odczyt danych profilu u¿ytkownika                           \\\hline
    \texttt{writeActivityWithTrack}  & funkcja     & \texttt{WRITE}  & Zapis aktywnoœci wraz ze œladem GPS                         \\\hline
    \texttt{deleteActivityWithTrack} & funkcja     & \texttt{DELETE} & Usuniêcie aktywnoœci wraz ze œladem GPS                     \\\hline
    \texttt{updateActivity}          & funkcja     & \texttt{UPDATE} & Aktualizacja danych aktywnoœci                              \\\hline
    \texttt{updateProfile}           & funkcja     & \texttt{UPDATE} & Aktualizacja danych profilu                                 \\\hline
    \texttt{updateUser}              & funkcja     & \texttt{UPDATE} & Aktualizacja danych profilu (tylko: imiê, nazwisko, awatar) \\\hline
  \end{tabularx}
\end{table}

Odczyt z bazy danych powoduje zarejestrowanie s³uchaczy (ang.~\emph{listener registration}), dziêki czemu zmiany w bazie danych s¹ od razu przesy³ane do aplikacji klienta. Aby w pe³ni wykorzystaæ potencja³ tej funkcjonalnoœci, wszystkie operacje \texttt{READ}, czyli: odczyt wszystkich aktywnoœci u¿ytkownika, odczyt œladu GPX u¿ytkownika i odczyt danych profilu u¿ytkownika zaimplementowano jako \emph{hooki}, zamiast jako zwyk³e funkcje.
Pozosta³e operacja mo¿na nazwaæ \emph{operacjami jednostronnymi}, tzn.:~wysy³aj¹ one jedynie zapytanie do bazy danych i nie rejestruj¹ ¿adnych s³uchaczy. Z tego powodu zaimplementowano je jako zwyk³e funkcje.

\emph{Hook} odczytu pokazano na listingu~\ref{lst:readactivities} na przyk³adzie \texttt{useReadActivities}. Zawiera on trzy stany:
\begin{enumerate}
  \item \texttt{profile} --- odczytane dane.
  \item \texttt{loading} --- odczytywanie danych.
  \item \texttt{error} ---- b³¹d odczytu danych.
\end{enumerate}
Funkcja \texttt{onValue} rejestruje s³uchacza, który z ka¿d¹ zmian¹ otrzyman¹ z bazy danych wywo³uje funkcjê \emph{callback} przekazan¹ jako drugi parametr. \emph{Hooki} \texttt{useReadTrack} i~\texttt{useReadActivities} zaprojektowano w pe³ni analogicznie. Ró¿ni¹ siê g³ównie typami danych oraz œcie¿kami odczytu.

  {\belowcaptionskip=-9pt
    \begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:readactivities, caption=\emph{Hook} odczytu danych profilu z bazy danych, basicstyle=\footnotesize\ttfamily]
export const useReadProfile = (userId: string | null) => {
  const [profile, setProfile] = useState<UserProfile | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<boolean>(false);
  useEffect(() => {
    let unsubscribe;
    try {
      if (!userId) { throw new Error('useReadProfile failed. UserID cannot be null.'); }
      const path = 'users/' + userId + '/profile';
      unsubscribe = onValue(ref(database, path), (snapshot) => {
        if (snapshot.exists()) { setProfile(snapshot.val()); }
        setLoading(false);
        setError(false);
      });
    } catch (er) {
      setProfile(null);
      setLoading(false);
      setError(true);
    } finally {
      return unsubscribe;
    }
  }, [userId]);
  return { profile, loading, error };
};
\end{lstlisting}}

Szczególnie interesuj¹ca jest funkcja \texttt{writeActivityWithTrack}, której kod pokazano na listingu~\ref{lst:writeactivities}. Obiekty \texttt{track} i \texttt{activity} w aplikacji klienta s¹ silnie ze sob¹ powi¹zane --- \texttt{track} mo¿na uznaæ za element nale¿¹cy do \texttt{activity}. Zatem wydawaæ by siê mog³o, ¿e w~bazie danych \texttt{track} powinien byæ zapisany jako potomek \texttt{activity}. Tymczasem w celu optymalizacji zapytañ do bazy danych, obiekty te zapisywane s¹ do ró¿nych œcie¿ek, jednak pod wspólnym identyfikatorem. W wyniku wywo³ania funkcji \texttt{push} zwracany jest obiekt zawieraj¹cy nowo wygenerowany, unikalny klucz, który s³u¿y jako wspólny identyfikator dla obiektów \texttt{activity} i \texttt{track}. Nastêpnie obiekty zapisywane s¹ do bazy wywo³aniem funkcji \texttt{set}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:writeactivities, caption=Funkcja zapisu aktywnoœci i œladu do bazy danych, basicstyle=\footnotesize\ttfamily]
export const writeActivityWithTrack = async (
  userId: string | null,
  activity: Activity,
  track: Track
): Promise<{ updatedActivity: Activity; updatedTrack: Track }> => {
  try {
    if (!userId) { throw new Error('UserID cannot be null'); }
    const activityParentPath = 'users/' + userId + '/activities';
    const activityId = push(child(ref(database), activityParentPath)).key || '';
    const updatedActivity = { ...activity, activityId };
    set(ref(database, activityParentPath + '/' + activityId), updatedActivity);
    const trackParentPath = 'users/' + userId + '/tracks';
    const updatedTrack = { ...track, activityId };
    set(ref(database, trackParentPath + '/' + activityId), updatedTrack);
    return { updatedActivity, updatedTrack };
  } catch (er) {
    throw new Error(`writeActivityWithTrack failed. ${er}`);
  }
};
\end{lstlisting}}

Ze wzglêdu na silne powi¹zanie \texttt{activty} --- \texttt{track} i sposób zapisu do bazy, usuniêcie danych wymaga wykonania operacji dla dwóch œcie¿ek, co pokazano na listingu~\ref{lst:deleteactivity}. Usuniêcie dokonuje siê przez wywo³anie funkcji \texttt{remove}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:deleteactivity, caption=Funkcja usuniêcia aktywnoœci i œladu z bazy danych, basicstyle=\footnotesize\ttfamily]
export const deleteActivityWithTrack = async (
  userId: string | null,
  activityId: string
): Promise<void> => {
  try {
    if (!userId) { throw new Error('UserID cannot be null');}
    const activityPath = 'users/' + userId + '/activities/' + activityId;
    const trackPath = 'users/' + userId + '/tracks/' + activityId;
    remove(ref(database, activityPath));
    remove(ref(database, trackPath));
    return;
  } catch (er) {
    throw new Error(`deleteActivityWithTrack failed. ${er}`);
  }
};
\end{lstlisting}}

Wszystkie funkcje wykonuj¹ce operacje \texttt{UPDATE} dzia³aj¹ w bardzo zbli¿ony do siebie sposób. Przyk³ad --- funkcjê \texttt{updateProfile} --- podano na listingu~\ref{lst:updateprofile}. Funkcje aktualizuj¹ce przyjmuj¹ jako parametr obiekt \texttt{payload}, który zawiera œcie¿ki wzglêdne do aktualizowanych kluczy, oraz nowe wartoœci dla tych kluczy. Zapytanie do bazy wykonywane jest przez wywo³anie \texttt{updateActivity}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:updateprofile, caption=Funkcja aktualizacji danych profilu, basicstyle=\footnotesize\ttfamily]
export const updateActivity = async (
  userId: string | null,
  activityId: string,
  payload: { [field: string]: any }
) => {
  try {
    if (!userId) { throw new Error('UserID cannot be null'); }
    const activityPath = 'users/' + userId + '/activities/' + activityId;
    update(ref(database, activityPath), payload);
    return;
  } catch (er) {
    throw new Error(`deleteActivityWithTrack failed. ${er}`);
  }
};
\end{lstlisting}}

Baza danych zabezpieczono prost¹ regu³¹: tylko u¿ytkownik uwierzytelniony mo¿e odczytywaæ tylko w³asne dane. Regu³ê pokazano na listingu~\ref{lst:dbrule}

{\belowcaptionskip=-9pt
  \begin{lstlisting}[style=json-style, label=lst:dbrule, caption=Regu³y zabezpieczeñ bazy danych, basicstyle=\footnotesize\ttfamily]
{
  "rules": {
    "users": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
      }
    }
  }
}
\end{lstlisting}
}

\section{Implementacja profilu u¿ytkownika}
Strona profilu u¿ytkownika (rys.~\ref{fig:profileview}) sk³ada siê z czterech g³ównych sekcji: awatara, danych u¿ytkownika, statystyk oraz wykresów. W sekcji awatara zawarto zdjêcie u¿ytkownika. Klikniêcie zdjêcia powoduje pojawienie siê pola tekstowego, w którym u¿ytkownik mo¿e podaæ adres URL nowego zdjêcia. U¿ytkownik mo¿e równie¿ edytowaæ swoje imiê i nazwisko. Powy¿sze dane aktualizowane s¹ po stronie backendu wywo³aniami funkcji \texttt{updateUser} (tab.~\ref{tab:crudy}), co przedstawiono na listingu~\ref{lst:updateavatar}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:updateavatar, caption=Aktualizacja zdjêcia oraz imienia i nazwiska profilu, basicstyle=\footnotesize\ttfamily]
const onNameChange = (newName: string) => {
  if (newName === '') {
    message.error('Invalid name');
    return;
  }
  updateUser({ displayName: newName })
    .then(() => {
      message.success('Name updated');
      setName(newName);
    })
    .catch(() => {
      message.error("Name couldn't be updated");
    });
};
const onUrlChange = (newUrl: string) => {
  updateUser({ photoURL: newUrl })
    .then(() => {
      message.success('Photo updated');
      setUrl(newUrl);
    })
    .catch(() => {
      message.error("Photo couldn't be updated");
    });
};
\end{lstlisting}}

W karcie \texttt{Bio} prezentowane s¹ dane u¿ytkownika odczytywane z obiektu typu \texttt{UserProfile} (lis.~\ref{lst:dbtypes1}). Ich edycja przebiega podobnie jak w przypadku edycji imienia i nazwiska, jednak tym razem wywo³ywana jest funkcja \texttt{updateProfile} (tab.~\ref{tab:crudy}). Przyk³ad pokazano na lisitngu~\ref{lst:updateuserprofile}. Aktualizacja pozosta³ych pól przebiega analogicznie w stosunku do funkcji~\texttt{onDescriptionChange}.

{\belowcaptionskip=-9pt
\begin{lstlisting}[language=JavaScript, style=JavaScriptStyle, label=lst:updateuserprofile, caption=Aktualizacja danych profilu na przyk³adzie zmiany opisu, basicstyle=\footnotesize\ttfamily]
  const onProfileUpdate = async (
    field: string,
    payload: { [filed: string]: any }
  ) => {
    updateProfile(currentUserId, payload)
      .then(() => {
        message.success(field + ' updated');
      })
      .catch(() => {
        message.error(field + " couldn't be updated");
      });
  };
  const onDescriptionChange = (newDescription: string) => {
    onProfileUpdate('Description', { description: newDescription }).then(() => {
      setDescription(newDescription);
    });
  };
\end{lstlisting}}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\linewidth]{rys03/profileview}
  \caption{Widok strony profilu u¿ytkownika}
  \label{fig:profileview}
\end{figure}

\section{Implementacja statystyk profilu u¿ytkownika}
Funkcjê obliczaj¹c¹ statystyki profilu zaimplementowano w komponencie \texttt{ProfileDashboard} (rys.~\ref{fig:profilestats}). Algorytm funkcji polega na iteracji przez tablicê wszystkich aktywnoœci (obiekty typu \texttt{Activity} --- listing~\ref{lst:dbtypes2}) u¿ytkownika. W danych wyszukiwane s¹ (poprzez zliczanie wyst¹pieñ wartoœci lub proste porównania wartoœci) nastêpuj¹ce wartoœci:
\begin{itemize}
  \item \texttt{numberOfActivities} --- ca³kowita liczba aktywnoœci;
  \item \texttt{maxSpeed} --- maksymalna zarejestrowana prêdkoœæ;
  \item \texttt{firstActivityAt} --- data pierwszej aktywnoœci;
  \item \texttt{lastActivityAt} --- data ostatniej aktywnoœci;
  \item \texttt{totalDuration} --- ca³kowity czas aktywnoœci (czas ca³kowity);
  \item \texttt{averageDuration} --- œredni czas trwania aktywnoœci (czas ca³kowity);
  \item \texttt{minDuration} --- najkrótsza aktywnoœæ (czas ca³kowity);
  \item \texttt{maxDuration} --- najd³u¿sza aktywnoœæ (czas ca³kowity);
  \item \texttt{averageSpeed} --- œrednia prêdkoœæ (czas ca³kowity);
  \item \texttt{inMotionDuration} --- ca³kowity czas aktywnoœci (czas w ruchu);
  \item \texttt{averageInMotionDuration} --- œredni czas trwania aktywnoœci (czas w ruchu);
  \item \texttt{minInMotionDuration} --- najkrótsza aktywnoœæ (czas w ruchu);
  \item \texttt{maxInMotionDuration} --- najd³u¿sza aktywnoœæ (czas w ruchu);
  \item \texttt{averageSpeedInMotion} --- œrednia prêdkoœæ (czas w ruchu);
  \item \texttt{totalDistance} --- ca³kowity dystans;
  \item \texttt{averageDistance} --- œredni dystans;
  \item \texttt{minDistance} --- najkrótszy dystans;
  \item \texttt{maxDistance} --- najd³u¿szy dystans;
  \item \texttt{totalElevationUp} --- suma przewy¿szeñ w górê;
  \item \texttt{totalElevationDown} --- suma przewy¿szeñ w dó³;
  \item \texttt{minElevation} --- najni¿sze zarejestrowane po³o¿enie nad poziomem morza;
  \item \texttt{maxElevation} --- najwy¿sze zarejestrowane po³o¿enie nad poziomem morza.
\end{itemize}
Ze wzglêdu na rozmiar (d³ugoœæ kodu) funkcji oraz jej trywialn¹ implementacjê, kodu nie pokazano na ¿adnym listingu.

\begin{figure}[hb]
  \centering
  \includegraphics[width=0.9\linewidth]{rys03/stats}
  \caption{Widok statystyk profilu u¿ytkownika}
  \label{fig:profilestats}
\end{figure}

\section{Implementacja wykresów profilu u¿ytkownika}
Komponent \texttt{ProfileCharts} odpowiedzialny jest za prezentacjê wykresów profilu u¿ytkownika. Komponent przyjmuje jako w³aœciwoœæ tablicê obiektów \texttt{Activity}. Na pocz¹tku dane aktywnoœci mapowane s¹ na serie danych obs³ugiwane przez wykresy z biblioteki \texttt{React-Vis}. Nastêpnie serie danych przekazywane s¹ do komponentów odpowiednich wykresów, które je formatuj¹ i wyœwietlaj¹. Przyk³adowe wykresy zaprezentowano na rysunku~\ref{fig:profilecharts}. Kompletna lista wykresów profilu u¿ytkownika jest nastêpuj¹ca: \begin{itemize}
  \item dzienny dystans na przestrzeni ostatnich 30 dni;
  \item dzienny czasu aktywnoœci na przestrzeni ostatnich 30 dni;
  \item dzienne przewy¿szenia na przestrzeni ostatnich 30 dni;
  \item najczêœciej wybierane rodzaje sportu;
  \item najczêœciej wybierane kategorie;
  \item najczêœciej wybierane oceny;
  \item najczêœciej u¿ywane tagów;
  \item najczêœciej wybierane kszta³ty aktywnoœci.
\end{itemize}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\linewidth]{rys03/charts}
  \caption{Widok wykresów profilu u¿ytkownika}
  \label{fig:profilecharts}
\end{figure}
